import solve from '@mattflow/sudoku-solver';
import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { getSudoku } from 'fake-sudoku-puzzle-generator';


/**
 * @param {('veryeasy' | 'easy' | 'medium' | 'hard')} difficulty
 * @returns {number[][]}
 */
export function generateSudoku(difficulty = 'easy') {
	const sudoku = getSudoku(difficulty);

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (sudoku[row][col] === null) sudoku[row][col] = 0;
		}
	}

	return sudoku;
}


/**
 * @param {number[][]} sudoku
 */
export function solveSudoku(sudoku) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	const solution = solve(sudoku.flat().join(''), {
		outputArray: true,
		hintCheck: false
	});

	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		const [row, col] = GRID_COORDS[cell];
		grid[row][col] = solution[cell];
	}

	return grid;
}


/**
 * @param {number[][]} sudoku
 */
export function printSudoku(sudoku) {
	let out = '╔═══════╤═══════╤═══════╗\n';

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		if (row !== 0 && row % BOX_SIZE === 0) {
			out += '╟───────┼───────┼───────╢\n';
		}

		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (col === 0) {
				out += '║ ';
			} else if (col % BOX_SIZE === 0) {
				out += '│ ';
			}

			out += (sudoku[row][col] === 0 ? '·' : sudoku[row][col]) + ' ';

			if (col === SUDOKU_SIZE - 1) {
				out += '║';
			}
		}

		out += '\n';
	}

	out += '╚═══════╧═══════╧═══════╝';

	console.log(out);
}

/**
 * 获取当前棋盘的候选值
 * @param {number[][]} grid - 当前棋盘 (9x9)
 * @returns {Array<Array<number>>} - 返回一个 9x9 的候选值数组
 */
export function getCandidates(grid) {
	const SUDOKU_SIZE = 9;
	const BOX_SIZE = 3;

	// 初始化候选值数组
	const candidates = Array.from({ length: SUDOKU_SIZE }, () => Array.from({ length: SUDOKU_SIZE }, () => []));

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		for (let col = 0; col < SUDOKU_SIZE; col++) {
			// 如果当前格子已有确定值，候选值为空
			if (grid[row][col] !== 0) {
				candidates[row][col] = [];
				continue;
			}

			// 候选值为 1 到 9
			const possibleValues = new Set(Array.from({ length: SUDOKU_SIZE }, (_, i) => i + 1));

			// 移除同一行中的已确定数字
			for (let c = 0; c < SUDOKU_SIZE; c++) {
				if (grid[row][c] !== 0) {
					possibleValues.delete(grid[row][c]);
				}
			}

			// 移除同一列中的已确定数字
			for (let r = 0; r < SUDOKU_SIZE; r++) {
				if (grid[r][col] !== 0) {
					possibleValues.delete(grid[r][col]);
				}
			}

			// 移除同一宫格中的已确定数字
			const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
			const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
			for (let r = startRow; r < startRow + BOX_SIZE; r++) {
				for (let c = startCol; c < startCol + BOX_SIZE; c++) {
					if (grid[r][c] !== 0) {
						possibleValues.delete(grid[r][c]);
					}
				}
			}

			// 将候选值添加到候选值数组中
			candidates[row][col] = Array.from(possibleValues);
		}
	}

	return candidates;
}