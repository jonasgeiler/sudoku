import { Strategy } from '@sudoku/strategy/strategy.js';
import {basicStragety} from '@sudoku/strategy/basicStrategy.js'
// import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';

const BOX_SIZE = 3;
const SUDOKU_SIZE = 9;

export class ThreeDMedusaStrategy extends Strategy {
    constructor() {
        super(4, "3D Medusa"); // "3D Medusa"是策略名称
    }

    apply(sudoku) {
        // 获取所有可能候选值
        const [allCandidates, allReason] = basicStragety.apply(sudoku);
        console.log("初始候选数：", JSON.stringify(allCandidates));

        // 确定推理起始单元格
        const [inirow1, inicol1, inirow2, inicol2, num] = this.findOptimalMedusaStartPoint(allCandidates);
        //const [inirow1, inicol1, inirow2, inicol2, num] = [1,6,2,6,9]
        console.log([inirow1, inicol1, inirow2, inicol2])

        // 构建强链接和弱链接
        const links = this.buildLinks(inirow1, inicol1, inirow2, inicol2, num, allCandidates);
        console.log(links)
        //console.log("构建的链接：", JSON.stringify(links));

        // 应用3D Medusa规则
        //this.applyMedusaRules(links, allCandidates, allReason);
        //console.log("最终候选数：", JSON.stringify(allCandidates));
        //return [allCandidates, allReason];
        const [updatedCandidates, updatedReason] = this.applyMedusaRules(links, allCandidates, allReason);
        console.log("最终候选数：", JSON.stringify(updatedCandidates));

        return [updatedCandidates, updatedReason];
    }


    /**
     * 寻找并返回一个适合作为美杜莎链起点的单元格对。
     * @param {Array<Array<Array<number>>>} allCandidates - 包含每个单元格候选数的二维数组。
     * @returns {[number, number, number, number, number]} - 选中的起始单元格对的行和列索引及共享的候选数。
     */
    findIniUnit(allCandidates) {
        const SUDOKU_SIZE = allCandidates.length;

        // 遍历所有单元格，寻找包含两个候选数的单元格作为潜在的起始点
        for (let row = 0; row < SUDOKU_SIZE; row++) {
            for (let col = 0; col < SUDOKU_SIZE; col++) {
                if (allCandidates[row][col].length === 2) {
                    const [num1, num2] = allCandidates[row][col];

                    // 检查行、列和九宫格内是否有其他单元格也包含相同的候选数之一
                    // 行内查找
                    for (let c = 0; c < SUDOKU_SIZE; c++) {
                        if (c !== col && allCandidates[row][c].includes(num1)) {
                            return [row, col, row, c, num1];
                        }
                        if (c !== col && allCandidates[row][c].includes(num2)) {
                            return [row, col, row, c, num2];
                        }
                    }

                    // 列内查找
                    for (let r = 0; r < SUDOKU_SIZE; r++) {
                        if (r !== row && allCandidates[r][col].includes(num1)) {
                            return [row, col, r, col, num1];
                        }
                        if (r !== row && allCandidates[r][col].includes(num2)) {
                            return [row, col, r, col, num2];
                        }
                    }

                    // 九宫格内查找
                    const boxRowStart = Math.floor(row / 3) * 3;
                    const boxColStart = Math.floor(col / 3) * 3;
                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            let br = boxRowStart + r;
                            let bc = boxColStart + c;
                            if (br !== row && bc !== col && allCandidates[br][bc].includes(num1)) {
                                return [row, col, br, bc, num1];
                            }
                            if (br !== row && bc !== col && allCandidates[br][bc].includes(num2)) {
                                return [row, col, br, bc, num2];
                            }
                        }
                    }
                }
            }
        }

        // 如果没有找到合适的起始单元格对，则返回默认值
        console.warn("未找到合适的起始单元格对");
        return [-1, -1, -1, -1, -1];
    }

    /**
     * 寻找并返回一个最适合作为美杜莎链起点的单元格对。以二值格、强链接数量作为筛选标准。
     * @param {Array<Array<Array<number>>>} allCandidates - 包含每个单元格候选数的二维数组。
     * @returns {[number, number, number, number, number]} - 选中的起始单元格对的行和列索引及共享的候选数。
     */
    findOptimalMedusaStartPoint(allCandidates) {
        // 辅助函数：检查是否为二值单元格
        function isBivalueCell(candidates) {
            return candidates.length === 2;
        }

        // 辅助函数：查找强链接（行、列或九宫格内某候选数仅出现两次）
        function findStrongLinks(unit, num) {
            let positions = [];
            for (let i = 0; i < unit.length; i++) {
                if (unit[i].includes(num)) {
                    positions.push(i);
                }
            }
            return positions.length === 2 ? positions : null;
        }

        // 辅助函数：计算某个二值单元格的强链接条数
        function countStrongLinks(row, col) {
            let links = 0;
            const [num1, num2] = allCandidates[row][col];

            // 行内的强链接
            [num1, num2].forEach(num => {
                let positions = findStrongLinks(allCandidates[row], num);
                if (positions && positions.length === 2) {
                    links++;
                }
            });

            // 列内的强链接
            [num1, num2].forEach(num => {
                let positions = [];
                for (let r = 0; r < SUDOKU_SIZE; r++) {
                    if (allCandidates[r][col].includes(num)) {
                        positions.push(r);
                    }
                }
                if (positions.length === 2) {
                    links++;
                }
            });

            // 九宫格内的强链接
            [num1, num2].forEach(num => {
                let positions = [];
                const boxRowStart = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const boxColStart = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let r = 0; r < BOX_SIZE; r++) {
                    for (let c = 0; c < BOX_SIZE; c++) {
                        let br = boxRowStart + r;
                        let bc = boxColStart + c;
                        if (allCandidates[br][bc].includes(num)) {
                            positions.push([br, bc]);
                        }
                    }
                }
                if (positions.length === 2) {
                    links++;
                }
            });

            return links;
        }

        // 收集所有二值单元格及其强链接条数
        let bivalueCells = [];

        for (let row = 0; row < SUDOKU_SIZE; row++) {
            for (let col = 0; col < SUDOKU_SIZE; col++) {
                if (isBivalueCell(allCandidates[row][col])) {
                    const strongLinksCount = countStrongLinks(row, col);
                    bivalueCells.push({ row, col, strongLinks: strongLinksCount });
                }
            }
        }

        // 根据强链接条数排序，选择最多的
        bivalueCells.sort((a, b) => b.strongLinks - a.strongLinks);

        // 如果没有找到二值单元格，返回null
        if (bivalueCells.length === 0) {
            return [-1,-1,-1,-1,-1];
        }

        // 获取强链接条数最多的二值单元格
        const bestBivalueCell = bivalueCells[0];
        const [num1, num2] = allCandidates[bestBivalueCell.row][bestBivalueCell.col];

        // 返回最优起始点，格式化为 [row1, col1, row2, col2, sharedNum]
        return [bestBivalueCell.row, bestBivalueCell.col, bestBivalueCell.row, bestBivalueCell.col, num1];
    }

    /**
     * 构建美杜莎链，从给定的起始单元格对开始，使用迭代而非递归。
     * @param {number} inirow1 - 第一个起始单元格的行索引。
     * @param {number} inicol1 - 第一个起始单元格的列索引。
     * @param {number} inirow2 - 第二个起始单元格的行索引。
     * @param {number} inicol2 - 第二个起始单元格的列索引。
     * @param {number} sharedNum - 两个起始单元格共享的候选数。
     * @param {Array<Array<Array<number>>>} allCandidates - 包含每个单元格候选数的二维数组。
     * @returns {Object} - 包含所有链接的对象。
     */
    buildLinks(inirow1, inicol1, inirow2, inicol2, sharedNum, allCandidates) {
        if (inirow1 === -1 || inicol1 === -1 || inirow2 === -1 || inicol2 === -1 || sharedNum === -1) {
            return {}; // 如果没有找到合适的起点，则返回空链接对象
        }

        const links = {};
        const colors = new Map(); // 使用Map来存储颜色分配
        const RED = 'red';
        const BLUE = 'blue';

        // 初始化颜色：从起始单元格的共享候选数开始，分别设为红色和蓝色
        colors.set(`${inirow1},${inicol1},${sharedNum}`, RED);
        //colors.set(`${inirow2},${inicol2},${sharedNum}`, BLUE);

        // 辅助函数：检查并添加链接
        function addLink(row, col, num, color) {
            const key = `${row},${col},${num}`;
            if (!links[key] || links[key].color===null) {
                links[key] = {
                    row: row,
                    col: col,
                    num: num,
                    color: color,
                    linkedTo: []
                };
            }
            return links[key];
        }

        // 队列用于迭代处理单元格和数字对
        const queue = [
            { row: inirow1, col: inicol1, num: sharedNum, color: RED },
            //{ row: inirow2, col: inicol2, num: sharedNum, color: BLUE }
        ];

        while (queue.length > 0) {
            const { row, col, num, color } = queue.shift();
            const oppositeColor = color === RED ? BLUE : RED;

            // 添加当前链接
            const currentLink = addLink(row, col, num, color);

            // 强链接的搜索与添加
            // 同一单元格
            if (allCandidates[row][col].length === 2){
                let nextnum = -1;
                if (allCandidates[row][col][0] !== num){
                    nextnum = allCandidates[row][col][0];
                }
                else {
                    nextnum = allCandidates[row][col][1];
                }
                const nextCellKey = `${row},${col},${nextnum}`;
                if (!colors.has(nextCellKey)) {
                    colors.set(nextCellKey, oppositeColor);
                    const nextLink = addLink(row, col, nextnum, oppositeColor);
                    currentLink.linkedTo.push(nextLink);
                    queue.push({ row: row, col: col, num: nextnum, color: oppositeColor });
                }
            }
            // 查找行、列、九宫格内的其他位置
            let count = 1; //同一单元中值为num的候选值的个数，恰好为2时才是强链接
            let nextrow = -1; let nextcol = -1;
            let nextCellKey = `${-1},${-1},${-1}`;
            // 行
            nextrow = row;
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                if (i !== col && allCandidates[row][i].includes(num)) {
                    count = count + 1;
                    nextcol = i;
                }
            }
            if (count === 2){
                nextCellKey = `${nextrow},${nextcol},${num}`;
                if (!colors.has(nextCellKey)) {
                    colors.set(nextCellKey, oppositeColor);
                    const nextLink = addLink(nextrow, nextcol, num, oppositeColor);
                    currentLink.linkedTo.push(nextLink);
                    queue.push({ row: nextrow, col: nextcol, num: num, color: oppositeColor });
                }
            }
            // 列
            count = 1;
            nextcol = col;
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                if (i !== row && allCandidates[i][col].includes(num)) {
                    count = count + 1;
                    nextrow = i;
                }
            }
            if (count === 2){
                nextCellKey = `${nextrow},${nextcol},${num}`;
                if (!colors.has(nextCellKey)) {
                    colors.set(nextCellKey, oppositeColor);
                    const nextLink = addLink(nextrow, nextcol, num, oppositeColor);
                    currentLink.linkedTo.push(nextLink);
                    queue.push({ row: nextrow, col: nextcol, num: num, color: oppositeColor });
                }
            }
            // 九宫格
            count = 1;
            const boxRowStart = Math.floor(row / BOX_SIZE) * BOX_SIZE;
            const boxColStart = Math.floor(col / BOX_SIZE) * BOX_SIZE;
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    let br = boxRowStart + r;
                    let bc = boxColStart + c;
                    if ((br !== row || bc !== col) && allCandidates[br][bc].includes(num)) {
                        count = count + 1;
                        nextrow = br;
                        nextcol = bc;
                        }
                }
            }
            if (count === 2){
                nextCellKey = `${nextrow},${nextcol},${num}`;
                if (!colors.has(nextCellKey)) {
                    colors.set(nextCellKey, oppositeColor);
                    const nextLink = addLink(nextrow, nextcol, num, oppositeColor);
                    currentLink.linkedTo.push(nextLink);
                    queue.push({ row: nextrow, col: nextcol, num: num, color: oppositeColor });
                }
            }

            // 检查当前单元格内的其他候选数（弱链接）
            for (let otherNum of allCandidates[row][col]) {
                if (otherNum !== num) {
                    const weakLinkKey = `${row},${col},${otherNum}`;
                    if (!links[weakLinkKey]) {
                        links[weakLinkKey] = {
                            row: row,
                            col: col,
                            num: otherNum,
                            color: null, // 弱链接不分配颜色
                            linkedTo: []
                        };
                    }
                }
            }
        }

        return links;
    }

    /**
     * 应用3D Medusa规则更新候选数。
     * @param {Object} links - 包含所有链接的对象。
     * @param {Array<Array<Array<number>>>} allCandidates - 包含每个单元格候选数的二维数组。
     * @param {Array<String>} allReason - 解题过程的理由记录。
     * @returns {[Array<Array<Array<number>>>, Array<String>]} - 更新后的候选数列表和解题理由。
     */
    applyMedusaRules(links, allCandidates, allReason) {
        const RED = 'red';
        const BLUE = 'blue';

        // 用于记录逻辑链的日志对象
        let chainLog = [];

        // 辅助函数：记录逻辑链
        function logChainAction(action, details) {
            chainLog.push({ action, details });
        }

        // 规则1: 单元格中有两个相同颜色的候选值
        function ruleOne() {
            for (const key in links) {
                const link = links[key];
                if (link.color) {
                    const otherCandidateKeys = allCandidates[link.row][link.col].map(num => `${link.row},${link.col},${num}`).filter(k => k !== key);
                    for (let otherKey of otherCandidateKeys) {
                        const otherLink = links[otherKey];
                        if (otherLink && otherLink.color === link.color) {
                            console.log(`规则1: 在(${link.row},${link.col})发现两个${link.color}颜色的候选数`);
                            return link.color;
                        }
                    }
                }
            }
            return null;
        }

        // 规则2: 同一行/列/九宫格中的两个相同候选值具有相同的颜色
        function ruleTwo() {
            const seenColors = new Map();

            for (const key in links) {
                const link = links[key];
                if (link.color) {
                    // 分别处理行、列和九宫格
                    const [rowColor, colColor, boxColor] = checkUnitColors(link.row, link.col, link.num, link.color);

                    // 如果任意一个单元中发现了相同的颜色，则返回该颜色作为矛盾颜色
                    if (rowColor || colColor || boxColor) {
                        console.log(`规则2: 在${rowColor ? '行' : ''}${colColor ? '列' : ''}${boxColor ? '九宫格' : ''}发现两个${link.color}颜色的候选数`);
                        return link.color;
                    }
                }
            }
            return null;
        }

        // 检查行、列、九宫格内的颜色冲突
        function checkUnitColors(row, col, num, color) {
            let rowColor = false;
            let colColor = false;
            let boxColor = false;

            // 行内查找
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                if (c !== col && links[`${row},${c},${num}`]?.color === color) {
                    rowColor = true;
                    break;
                }
            }

            // 列内查找
            for (let r = 0; r < SUDOKU_SIZE; r++) {
                if (r !== row && links[`${r},${col},${num}`]?.color === color) {
                    colColor = true;
                    break;
                }
            }

            // 九宫格内查找
            const boxRowStart = Math.floor(row / BOX_SIZE) * BOX_SIZE;
            const boxColStart = Math.floor(col / BOX_SIZE) * BOX_SIZE;
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    let br = boxRowStart + r;
                    let bc = boxColStart + c;
                    if ((br !== row || bc !== col) && links[`${br},${bc},${num}`]?.color === color) {
                        boxColor = true;
                        break;
                    }
                }
                if (boxColor) break;
            }

            return [rowColor, colColor, boxColor];
        }

        // 获取同一行、列或九宫格的所有键
        function getUnitKeys(row, col, num) {
            const rowKeys = [];
            const colKeys = [];
            const boxKeys = [];

            // 行内查找
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                rowKeys.push(`${row},${c},${num}`);
            }

            // 列内查找
            for (let r = 0; r < SUDOKU_SIZE; r++) {
                colKeys.push(`${r},${col},${num}`);
            }

            // 九宫格内查找
            const boxRowStart = Math.floor(row / BOX_SIZE) * BOX_SIZE;
            const boxColStart = Math.floor(col / BOX_SIZE) * BOX_SIZE;
            for (let r = 0; r < BOX_SIZE; r++) {
                for (let c = 0; c < BOX_SIZE; c++) {
                    let br = boxRowStart + r;
                    let bc = boxColStart + c;
                    boxKeys.push(`${br},${bc},${num}`);
                }
            }

            return [...new Set([...rowKeys, ...colKeys, ...boxKeys])];
        }

        // 规则3: 单元格中有两种颜色的候选值和其他候选值
        function ruleThree() {
            for (const key in links) {
                const link = links[key];
                if (link.color) {
                    const cellLinks = Object.values(links).filter(l => l.row === link.row && l.col === link.col && l.color);
                    const colorsInCell = new Set(cellLinks.map(l => l.color));
                    if (colorsInCell.size === 2) {
                        const [color1, color2] = colorsInCell;
                        const oppositeColor = color1 === RED ? BLUE : RED;

                        // 移除其他颜色的候选数
                        allCandidates[link.row][link.col] = allCandidates[link.row][link.col].filter(num => {
                            const candidateKey = `${link.row},${link.col},${num}`;
                            const candidateLink = links[candidateKey];
                            return !candidateLink || candidateLink.color === color1 || candidateLink.color === color2;
                        });

                        // 记录解题理由
                        allReason[link.row][link.col] = `3DMedusa 移除 (${link.row},${link.col}) 中非 ${color1}/${color2} 颜色的候选数`
                        console.log(`移除 (${link.row},${link.col}) 中非 ${color1}/${color2} 颜色的候选数`);

                        // 记录逻辑链
                        logChainAction('remove', {
                            position: [link.row, link.col],
                            reason: `因为存在两种颜色 ${color1} 和 ${color2}`
                        });
                    }
                }
            }
        }

        // 规则4: 某单元格中的某候选值，在它所在的行/列/九宫格中找到两种颜色的相同候选值
        function ruleFour() {
            for (const key in links) {
                const link = links[key];
                if (!link.color) { // 只考虑未着色的链接
                    const unitKeys = getUnitKeys(link.row, link.col, link.num);

                    // 获取单元内所有已着色且候选值相同的链接的颜色
                    const colorsInUnit = new Set(
                        Object.values(links)
                            .filter(l =>
                                l.color && // 已着色
                                unitKeys.includes(`${l.row},${l.col},${l.num}`) && // 在同一单元内
                                l.num === link.num // 候选值相同
                            )
                            .map(l => l.color)
                    );

                    if (colorsInUnit.size === 2) { // 如果在单元内找到了两种颜色的相同候选值
                        allCandidates[link.row][link.col] = allCandidates[link.row][link.col].filter(num => num !== link.num);

                        // 记录解题理由
                        allReason[link.row][link.col] = `3DMedusa 移除 (${link.row},${link.col}) 中的 ${link.num} 因为在其所在单元找到了两种颜色的相同候选值`;
                        console.log(`移除 (${link.row},${link.col}) 中的 ${link.num} 因为在其所在单元找到了两种颜色的相同候选值`);

                        // 记录逻辑链
                        logChainAction('remove', {
                            num: link.num,
                            position: [link.row, link.col],
                            reason: `因为在所在单元找到了两种颜色的相同候选值`
                        });
                    }
                }
            }
        }

        // 规则5: 未着色的候选值可以在其他地方看到一个有色的候选值（共享行/列/九宫格），而在自己的单元格中可以看到相反的有色候选值
        function ruleFive() {
            for (const key in links) {
                const link = links[key];
                if (!link.color) {
                    const unitKeys = getUnitKeys(link.row, link.col, link.num);
                    const sameUnitLinks = Object.values(links).filter(l => unitKeys.includes(`${l.row},${l.col},${l.num}`));

                    const coloredLinks = sameUnitLinks.filter(l => l.color);
                    if (coloredLinks.length > 0) {
                        const oppositeColor = coloredLinks.some(l => l.color === RED) ? BLUE : RED;
                        const oppositeLinkInCell = Object.values(links).find(l => l.row === link.row && l.col === link.col && l.color === oppositeColor);

                        if (oppositeLinkInCell) {
                            allCandidates[link.row][link.col] = allCandidates[link.row][link.col].filter(num => num !== link.num);

                            // 记录解题理由
                            allReason[link.row][link.col] = `3DMedusa 移除 (${link.row},${link.col}) 中的 ${link.num} 因为在同一单元看到了相反颜色 ${oppositeColor}`
                            console.log(`移除 (${link.row},${link.col}) 中的 ${link.num} 因为在同一单元看到了相反颜色 ${oppositeColor}`);

                            // 记录逻辑链
                            logChainAction('remove', {
                                num: link.num,
                                position: [link.row, link.col],
                                reason: `因为在同一单元看到了相反颜色 ${oppositeColor}`
                            });
                        }
                    }
                }
            }
        }

        // 规则6: 找到一个所有候选值都未着色的单元格,所有未着色的候选值都能看到相同颜色的对应候选值，则可以推断出另一颜色是正确的。
        function ruleSix() {
            for (let row = 0; row < SUDOKU_SIZE; row++) {
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    if (allCandidates[row][col].length > 1) {
                        const uncoloredCandidates = allCandidates[row][col].filter(num => !links[`${row},${col},${num}`] || !links[`${row},${col},${num}`].color);

                        if (uncoloredCandidates.length === allCandidates[row][col].length) {
                            // 检查每个未着色候选值是否能看到相同颜色的对应候选值
                            const colorMap = new Map();
                            for (const num of uncoloredCandidates) {
                                const unitKeys = getUnitKeys(row, col, num);
                                const seenColors = new Set(unitKeys.map(key => links[key]?.color).filter(color => color));

                                if (seenColors.size === 1) {
                                    const [color] = seenColors;
                                    colorMap.set(num, color);
                                } else {
                                    break;
                                }
                            }

                            // 如果所有候选值都能看到相同颜色的对应候选值
                            if (colorMap.size === uncoloredCandidates.length) {
                                const oppositeColor = [...new Set([RED, BLUE])].find(color => ![...colorMap.values()].includes(color));

                                // 确定该单元格的唯一解决方案
                                const solutionNum = uncoloredCandidates.find(num => colorMap.get(num) !== oppositeColor);
                                allCandidates[row][col] = [solutionNum];

                                // 记录解题理由
                                allReason[link.row][link.col] = `确认 (${row},${col}) 的唯一解为 ${solutionNum} 因为其他颜色都看到了 ${oppositeColor}`
                                //allReason.push(`确认 (${row},${col}) 的唯一解为 ${solutionNum} 因为其他颜色都看到了 ${oppositeColor}`);

                                // 记录逻辑链
                                logChainAction('confirm', {
                                    num: solutionNum,
                                    position: [row, col],
                                    reason: `因为其他颜色都看到了 ${oppositeColor}`
                                });

                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // 应用规则
        function applyRules() {
            let contradictoryColor = ruleOne();
            if (contradictoryColor) {
                updateCandidatesBasedOnContradiction(contradictoryColor, links, allCandidates, allReason);
            }

            contradictoryColor = ruleTwo();
            if (contradictoryColor) {
                updateCandidatesBasedOnContradiction(contradictoryColor, links, allCandidates, allReason);
            }

            ruleThree();
            ruleFour();
            //ruleFive();
            //ruleSix();
        }

        // 根据找到的矛盾更新候选数
        function updateCandidatesBasedOnContradiction(contradictoryColor, links, allCandidates, allReason) {
            for (const key in links) {
                const link = links[key];
                if (link.color === contradictoryColor) {
                    allCandidates[link.row][link.col] = allCandidates[link.row][link.col].filter(num => num !== link.num);

                    // 记录解题理由
                    allReason[link.row][link.col] = `3DMedusa 移除 ${link.num} 在 (${link.row},${link.col}) 因为找到了${contradictoryColor}颜色的矛盾`
                    console.log(`移除 ${link.num} 在 (${link.row},${link.col}) 因为找到了${contradictoryColor}颜色的矛盾`);

                    // 记录逻辑链
                    logChainAction('remove', {
                        num: link.num,
                        position: [link.row, link.col],
                        reason: `因为找到了${contradictoryColor}颜色的矛盾`
                    });
                }
            }
        }

        // 执行规则
        applyRules();

        // 打印推理逻辑链
        //console.log("最终确定唯一候选值的逻辑链：", JSON.stringify(chainLog, null, 2));

        // 返回更新后的候选数列表和解题理由
        return [allCandidates, allReason];
    }
}

export const threeDMedusaStrategy = new ThreeDMedusaStrategy();

/*
// 调试信息
let sudoku = [
    [0, 0, 0, 3, 0, 0, 0, 8, 0],
    [5, 0, 0, 0, 0, 1, 0, 0, 3],
    [8, 0, 6, 0, 4, 0, 0, 0, 0],
    [4, 0, 0, 8, 3, 0, 0, 0, 2],
    [0, 0, 2, 0, 0, 0, 3, 0, 0],
    [9, 0, 0, 0, 7, 2, 0, 0, 1],
    [0, 0, 0, 0, 6, 0, 1, 0, 7],
    [7, 0, 0, 1, 0, 0, 0, 0, 4],
    [0, 9, 0, 0, 0, 5, 0, 0, 0],
];

let sudoku1 = [
    [0, 9, 3, 8, 2, 4, 5, 6, 0],
    [0, 8, 5, 6, 0, 0, 0, 0, 2],
    [2, 0, 6, 0, 7, 5, 0, 0, 8],
    [3, 2, 1, 7, 6, 9, 8, 4, 5],
    [0, 0, 0, 2, 5, 8, 3, 0, 0],
    [5, 7, 8, 0, 4, 0, 2, 9, 6],
    [8, 5, 0, 0, 1, 6, 7, 2, 3],
    [0, 0, 7, 0, 8, 2, 6, 5, 0],
    [0, 0, 2, 5, 0, 7, 1, 8, 0],
];

let sudoku2 = [
    [0, 9, 3, 8, 2, 4, 5, 6, 0],
    [0, 8, 5, 6, 3, 0, 9, 0, 2],
    [2, 1, 6, 0, 7, 5, 4, 0, 8],
    [3, 2, 1, 7, 6, 9, 8, 4, 5],
    [0, 0, 0, 2, 5, 8, 3, 0, 0],
    [5, 7, 8, 0, 4, 0, 2, 9, 6],
    [8, 5, 0, 0, 1, 6, 7, 2, 3],
    [0, 4, 7, 0, 8, 2, 6, 5, 0],
    [0, 0, 2, 5, 9, 7, 1, 8, 0],
];

let sudoku3 = [
    [7, 9, 3, 8, 2, 4, 5, 6, 1],
    [4, 8, 5, 6, 3, 1, 9, 7, 2],
    [2, 1, 6, 9, 7, 5, 4, 3, 8],
    [3, 2, 1, 7, 6, 9, 8, 4, 5],
    [9, 6, 4, 2, 5, 8, 3, 1, 7],
    [5, 7, 8, 1, 4, 3, 2, 9, 6],
    [8, 5, 9, 4, 1, 6, 7, 2, 3],
    [1, 4, 7, 3, 8, 2, 6, 5, 9],
    [6, 3, 2, 5, 9, 7, 1, 8, 4],
];

const [allCandidates, allReason] = threeDMedusaStrategy.apply(sudoku3);
console.log(allCandidates)
//console.log(allReason)
*/