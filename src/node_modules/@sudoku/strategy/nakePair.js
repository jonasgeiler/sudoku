import { Strategy } from '@sudoku/strategy/strategy.js';
import {basicStragety} from '@sudoku/strategy/basicStrategy.js'
// import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';


const BOX_SIZE = 3;
const  SUDOKU_SIZE = 9;



export class NakePairStrategy  extends Strategy {
    constructor() {
        super(2, "Nake Pair");
    }


    apply(sudoku) {
        const [allCandidates, allReason] = basicStragety.apply(sudoku);
        let change = true;
        while(change) {
            let oldAmount = basicStragety.getAmountCandidate(allCandidates);
            // 检查行
            for (let row = 0; row < SUDOKU_SIZE; row++) {
                this.findNakePairInRow(allCandidates, row, allReason);
            }
            // 检查列
            for (let col = 0; col < SUDOKU_SIZE; col++) {
                this.findNakePairInCol(allCandidates, col, allReason);
            }
            // 检查九宫格
            for (let boxRow = 0; boxRow < SUDOKU_SIZE/BOX_SIZE; boxRow++) {
                for (let boxCol = 0; boxCol < SUDOKU_SIZE/BOX_SIZE; boxCol++) {
                    this.findNakePairInBox(allCandidates, boxRow, boxCol, allReason);
                }
            }
            let newAmount = basicStragety.getAmountCandidate(allCandidates);
            change = !basicStragety.isSameAmount(oldAmount, newAmount);
        }
        return [allCandidates, allReason];
    }



    // 寻找同一行的nake pair
    findNakePairInRow(allCandidates, row, allReason) {
        for (let firstCol = 0; firstCol <SUDOKU_SIZE; firstCol ++) {
            // 找到第一个二元候选值
            if (allCandidates[row][firstCol].length == 2) {
                for (let nextCol = firstCol + 1; nextCol < SUDOKU_SIZE; nextCol ++) {
                    // 找到两个相同候选值的格子
                    if (allCandidates[row][nextCol].length === 2 && 
                        allCandidates[row][firstCol][0] === allCandidates[row][nextCol][0] &&
                        allCandidates[row][firstCol][1] === allCandidates[row][nextCol][1]) {
                            allReason[row][firstCol] = allReason[row][firstCol].concat([`[${row}, ${firstCol}] 和 [${row}, ${nextCol}] 是一对行Naked Pair, 候选值为${allCandidates[row][firstCol]}`]).filter(
                                element => !Array.isArray(element) || element.length !== 0);
                            allReason[row][firstCol] = [...new Set(allReason[row][firstCol])];
                            allReason[row][nextCol] = allReason[row][nextCol].concat([`[${row}, ${firstCol}] 和 [${row}, ${nextCol}] 是一对行Naked Pair, 候选值为${allCandidates[row][nextCol]}`]).filter(
                                element => !Array.isArray(element) || element.length !== 0);
                            allReason[row][nextCol] = [...new Set(allReason[row][nextCol])];
                            basicStragety.removeInRow(allCandidates, allReason,  [[row, firstCol], [row, nextCol]], 
                                [allCandidates[row][firstCol][0], allCandidates[row][firstCol][1]], row, this.description);
                    }
                }
            }
        }
    }


    // 寻找同一列的nake pair
    findNakePairInCol(allCandidates, col, allReason) {
        for (let firstRow = 0; firstRow <SUDOKU_SIZE; firstRow ++) {
            // 找到第一个二元候选值
            if (allCandidates[firstRow][col].length == 2) {
                for (let nextRow = firstRow + 1; nextRow < SUDOKU_SIZE; nextRow ++) {
                    // 找到两个相同候选值的格子
                    if (allCandidates[nextRow][col].length === 2 && 
                        allCandidates[firstRow][col][0] === allCandidates[nextRow][col][0] &&
                        allCandidates[firstRow][col][1] === allCandidates[nextRow][col][1]) {
                            // 显示理由
                            allReason[firstRow][col] = allReason[firstRow][col].concat([`[${firstRow}, ${col}] 和 [${nextRow}, ${col}] 是一对列Naked Pair, 候选值为${allCandidates[firstRow][col]}`]).filter(
                                element => !Array.isArray(element) || element.length !== 0);
                            allReason[firstRow][col] = [...new Set(allReason[firstRow][col])];
                            allReason[nextRow][col] = allReason[nextRow][col].concat([`[${firstRow}, ${col}] 和 [${nextRow}, ${col}] 是一对列Naked Pair, 候选值为${allCandidates[nextRow][col]}`]).filter(
                                element => !Array.isArray(element) || element.length !== 0);
                            allReason[nextRow][col] = [...new Set(allReason[nextRow][col])];
                            basicStragety.removeInCol(allCandidates, allReason,  [[firstRow, col], [nextRow, col]], 
                                [allCandidates[firstRow][col][0], allCandidates[firstRow][col][1]], col, this.description);
                            
                    }
                }
            }
        }
    }


    // 寻找同一个九宫格的nake pair
    findNakePairInBox(allCandidates, boxRow, boxCol, allReason) {
        for (let firstBoxIndex = 0; firstBoxIndex < BOX_SIZE*BOX_SIZE; firstBoxIndex ++) {
            let firstRow = boxRow*BOX_SIZE + Math.floor(firstBoxIndex / BOX_SIZE);
            let firstCol = boxCol*BOX_SIZE + firstBoxIndex % BOX_SIZE;
            // 找到第一个二元候选值
            if (allCandidates[firstRow][firstCol].length == 2) {
                for (let nextBoxIndex = firstBoxIndex + 1; nextBoxIndex <SUDOKU_SIZE; nextBoxIndex ++) {
                    let nextRow = boxRow*BOX_SIZE + Math.floor(nextBoxIndex / BOX_SIZE);
                    let nextCol = boxCol*BOX_SIZE + nextBoxIndex % BOX_SIZE;
                    // 找到两个相同候选值的格子
                    if (allCandidates[nextRow][nextCol].length === 2 && 
                        allCandidates[firstRow][firstCol][0] === allCandidates[nextRow][nextCol][0] &&
                        allCandidates[firstRow][firstCol][1] === allCandidates[nextRow][nextCol][1]) {
                            allReason[firstRow][firstCol] = allReason[firstRow][firstCol].concat([`[${firstRow}, ${firstCol}] 和 [${nextRow}, ${nextCol}] 是一对宫Naked Pair, 候选值为${allCandidates[firstRow][firstCol]}`]).filter(
                                element => !Array.isArray(element) || element.length !== 0);
                            allReason[firstRow][firstCol] = [...new Set(allReason[firstRow][firstCol])];
                            allReason[nextRow][nextCol] = allReason[nextRow][nextCol].concat([`[${firstRow}, ${firstCol}] 和 [${nextRow}, ${nextCol}] 是一对宫Naked Pair, 候选值为${allCandidates[nextRow][nextCol]}`]).filter(
                                element => !Array.isArray(element) || element.length !== 0);
                            allReason[nextRow][nextCol] = [...new Set(allReason[nextRow][nextCol])];
                            basicStragety.removeInBox(allCandidates, allReason, [[firstRow, firstCol], [nextRow, nextCol]], 
                                [allCandidates[firstRow][firstCol][0], allCandidates[firstRow][firstCol][1]], boxRow, boxCol, this.description);
                        }
                }
            }
        }
    }
}


export const nakePairStrategy = new NakePairStrategy()




/*
// 调试信息
let sudoku = [
    [0, 8, 0, 0, 9, 0, 0, 3, 0],
    [0, 3, 0, 0, 0, 0, 0, 6, 9],
    [9, 0, 2, 0, 6, 3, 1, 5, 8],
    [0, 2, 0, 8, 0, 4, 5, 9, 0],
    [8, 5, 1, 9, 0, 7, 0, 4, 6],
    [3, 9, 4, 6, 0, 5, 8, 7, 0],
    [5, 6, 3, 0, 4, 0, 9, 8, 7],
    [2, 0, 0, 0, 0, 0, 0, 1, 5],
    [0, 1, 0, 0, 5, 0, 0, 2, 0],
];
let sudoku1 = [
    [4, 0, 0, 0, 0, 0, 9, 3, 8],
    [0, 3, 2, 0, 9, 4, 1, 0, 0],
    [0, 9, 5, 3, 0, 0, 2, 4, 0],
    [3, 7, 0, 6, 0, 9, 0, 0, 4],
    [5, 2, 9, 0, 0, 1, 6, 7, 3],
    [6, 0, 4, 7, 0, 3, 0, 9, 0],
    [9, 5, 7, 0, 0, 8, 3, 0, 0],
    [0, 0, 3, 9, 0, 0, 4, 0, 0],
    [2, 4, 0, 0, 3, 0, 7, 0, 9],
];  

console.log(nakePairStrategy.apply(sudoku1));
*/
