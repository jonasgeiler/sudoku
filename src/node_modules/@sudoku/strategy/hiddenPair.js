import { Strategy } from '@sudoku/strategy/strategy.js';
import {basicStragety} from '@sudoku/strategy/basicStrategy.js'
// import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';


const BOX_SIZE = 3;
const  SUDOKU_SIZE = 9;



export class HiddenPairStrategy extends Strategy{
    constructor() {
        super(3, "Hidden Pair");
    }

    apply(sudoku) {
        const [allCandidates, allReason] = basicStragety.apply(sudoku);
        let change = true;
        while(change) {
            let oldAmount = basicStragety.getAmountCandidate(allCandidates);
            // 检查行
            for (let row = 0; row < SUDOKU_SIZE; row++) {
                this.findHiddenPairInRow(allCandidates, row, allReason);
            }
            // 检查列
            for (let col = 0; col < SUDOKU_SIZE; col++) {
                this.findHiddenPairInCol(allCandidates, col, allReason);
            }
            // 检查九宫格
            for (let boxRow = 0; boxRow < SUDOKU_SIZE/BOX_SIZE; boxRow++) {
                for (let boxCol = 0; boxCol < SUDOKU_SIZE/BOX_SIZE; boxCol++) {
                    this.findHiddenPairInBox(allCandidates, boxRow, boxCol, allReason);
                }
            }
            let newAmount = basicStragety.getAmountCandidate(allCandidates);
            change = !basicStragety.isSameAmount(oldAmount, newAmount);
        }
        return [allCandidates, allReason];
    }
    


    // 寻找同一行的hidden pair
    findHiddenPairInRow(allCandidates, row, allReason) {
        const candidateCounts = Array.from({ length: SUDOKU_SIZE + 1 }, () => new Set());
        // 统计每个数字在行中的出现位置
        for (let col = 0; col < SUDOKU_SIZE; col++) {
            allCandidates[row][col].forEach(num => candidateCounts[num].add(col));
        }
        // 查找只在两个单元格中出现的数字对
        for (let num1 = 1; num1 <= SUDOKU_SIZE; num1++) {
            for (let num2 = num1 + 1; num2 <= SUDOKU_SIZE; num2++){
                const combineSet = new Set([...candidateCounts[num1], ...candidateCounts[num2]]);
                // 如果只有两个位置存在这两个候选值，就构成hidden pair
                //if (combineSet.size === 2 && candidateCounts[num1].size >= 1 && candidateCounts[num2].size >= 1) {

                if (combineSet.size === 2 && candidateCounts[num1].size === 2 && candidateCounts[num2].size === 2) {
                    // 将者两个位置赋值为nake pair，清除其他无关候选值
                    const combineList = [...combineSet];
                    allCandidates[row][combineList[0]] = allCandidates[row][combineList[0]].filter(element => element === num1 || element === num2);
                    allCandidates[row][combineList[1]] = allCandidates[row][combineList[1]].filter(element => element === num1 || element === num2);
                    allReason[row][combineList[0]] = allReason[row][combineList[0]].concat([`[${row}, ${combineList[0]}] 和 [${row}, ${combineList[1]}] 是一对行Hidden Pair, 只保留候选值${allCandidates[row][combineList[0]]}`]).filter(
                        element => !Array.isArray(element) || element.length !== 0);
                    allReason[row][combineList[0]] = [...new Set(allReason[row][combineList[0]])];
                    allReason[row][combineList[1]] = allReason[row][combineList[1]].concat([`[${row}, ${combineList[0]}] 和 [${row}, ${combineList[1]}] 是一对行Hidden Pair, 只保留候选值${allCandidates[row][combineList[1]]}`]).filter(
                        element => !Array.isArray(element) || element.length !== 0);
                    allReason[row][combineList[1]] = [...new Set(allReason[row][combineList[1]])];
                    // 将同一行的无关元素全部清除
                    basicStragety.removeInRow(allCandidates, allReason, [[row, combineList[0]], [row, combineList[1]]], 
                        [num1, num2], row, this.description);
                    // 如果同时满足在同一个九宫格，同时消除九宫格里面的数字
                    if (basicStragety.isSameBox([[row, combineList[0]], [row, combineList[1]]])) {
                        basicStragety.removeInBox(allCandidates, allReason, [[row, combineList[0]], [row, combineList[1]]], 
                            [num1, num2], Math.floor(row / BOX_SIZE), Math.floor(combineList[0] / BOX_SIZE), this.description);
                    }
                }
            }
        }
    }



    // 寻找同一列的hidden pair
    findHiddenPairInCol(allCandidates, col, allReason) {
        const candidateCounts = Array.from({ length: SUDOKU_SIZE + 1 }, () => new Set());
        // 统计每个数字在行中的出现位置
        for (let row = 0; row < SUDOKU_SIZE; row++) {
            allCandidates[row][col].forEach(num => candidateCounts[num].add(row));
        }
        // 查找只在两个单元格中出现的数字对
        for (let num1 = 1; num1 <= SUDOKU_SIZE; num1++) {
            for (let num2 = num1 + 1; num2 <= SUDOKU_SIZE; num2++){
                const combineSet = new Set([...candidateCounts[num1], ...candidateCounts[num2]]);
                // 如果只有两个位置存在这两个候选值，就构成hidden pair
                //if (combineSet.size === 2 && candidateCounts[num1].size >= 1 && candidateCounts[num2].size >= 1) {
                if (combineSet.size === 2 && candidateCounts[num1].size === 2 && candidateCounts[num2].size === 2) {
                    // 将者两个位置赋值为nake pair，清除其他无关候选值
                    const combineList = [...combineSet];
                    allCandidates[combineList[0]][col] = allCandidates[combineList[0]][col].filter(element => element === num1 || element === num2);
                    allCandidates[combineList[1]][col] = allCandidates[combineList[1]][col].filter(element => element === num1 || element === num2);
                    allReason[combineList[0]][col] = allReason[combineList[0]][col].concat([`[${combineList[0]}, ${col}] 和 [${combineList[1]}, ${col}] 是一对列Hidden Pair, 只保留候选值${allCandidates[combineList[0]][col]}`]).filter(
                        element => !Array.isArray(element) || element.length !== 0);
                    allReason[combineList[0]][col] = [...new Set(allReason[combineList[0]][col])];
                    allReason[combineList[1]][col] = allReason[combineList[1]][col].concat([`[${combineList[0]}, ${col}] 和 [${combineList[1]}, ${col}] 是一对列Hidden Pair, 只保留候选值${allCandidates[combineList[1]][col]}`]).filter(
                        element => !Array.isArray(element) || element.length !== 0);
                    allReason[combineList[1]][col] = [...new Set(allReason[combineList[1]][col])];
                    // 将同一列的无关元素全部清除
                    basicStragety.removeInCol(allCandidates, allReason, [[combineList[0], col], [combineList[1], col]], 
                        [num1, num2], col, this.description);
                    // 如果同时满足在同一个九宫格，同时消除九宫格里面的数字
                    if (basicStragety.isSameBox([[combineList[0], col], [combineList[1], col]])) {
                        basicStragety.removeInBox(allCandidates, allReason, [[combineList[0], col], [combineList[1], col]], 
                            [num1, num2], Math.floor(combineList[0] / BOX_SIZE), Math.floor(col / BOX_SIZE), this.description);
                    }
                }
            }
        }

    } 



    // 寻找同一个九宫格的hidden pair
    findHiddenPairInBox(allCandidates, boxRow, boxCol, allReason) {
        const candidateCounts = Array.from({ length: SUDOKU_SIZE + 1 }, () => new Set());
        // 统计每个数字在行中的出现位置
        for (let boxIndex = 0; boxIndex < BOX_SIZE*BOX_SIZE; boxIndex ++) {
            let row = boxRow*BOX_SIZE + Math.floor(boxIndex / BOX_SIZE);
            let col = boxCol*BOX_SIZE + boxIndex % BOX_SIZE;
            allCandidates[row][col].forEach(num => candidateCounts[num].add([row, col]));
        }
        // 查找只在两个单元格中出现的数字对
        for (let num1 = 1; num1 <= SUDOKU_SIZE; num1++) {
            for (let num2 = num1 + 1; num2 <= SUDOKU_SIZE; num2++){
                const combineSet = new Set([...candidateCounts[num1], ...candidateCounts[num2]]);
                // 如果只有两个位置存在这两个候选值，就构成hidden pair
                //if (combineSet.size === 2 && candidateCounts[num1].size >= 1 && candidateCounts[num2].size >= 1) {
                if (combineSet.size === 2 && candidateCounts[num1].size === 2 && candidateCounts[num2].size === 2) {
                    // 将者两个位置赋值为nake pair，清除其他无关候选值
                    const combineList = [...combineSet];
                    allCandidates[combineList[0][0]][combineList[0][1]] = allCandidates[combineList[0][0]][combineList[0][1]].filter(element => element === num1 || element === num2);
                    allCandidates[combineList[1][0]][combineList[1][1]] = allCandidates[combineList[1][0]][combineList[1][1]].filter(element => element === num1 || element === num2);
                    allReason[combineList[0][0]][combineList[0][1]] = allReason[combineList[0][0]][combineList[0][1]].concat([`[${combineList[0][0]}, ${combineList[0][1]}] 和 [${combineList[1][0]}, ${combineList[1][1]}] 是一对宫Hidden Pair, 只保留候选值${allCandidates[combineList[0][0]][combineList[0][1]]}`]).filter(
                        element => !Array.isArray(element) || element.length !== 0);
                    allReason[combineList[0][0]][combineList[0][1]] = [...new Set(allReason[combineList[0][0]][combineList[0][1]])];
                    allReason[combineList[1][0]][combineList[1][1]] = allReason[combineList[1][0]][combineList[1][1]].concat([`[${combineList[0][0]}, ${combineList[0][1]}] 和 [${combineList[1][0]}, ${combineList[1][1]}] 是一对宫Hidden Pair, 只保留候选值${allCandidates[combineList[1][0]][combineList[1][1]]}`]).filter(
                        element => !Array.isArray(element) || element.length !== 0);
                    allReason[combineList[1][0]][combineList[1][1]]= [...new Set(allReason[combineList[1][0]][combineList[1][1]])];
                    // 将同一九宫格的无关元素全部清除
                    basicStragety.removeInBox(allCandidates, allReason, [[combineList[0][0],combineList[0][1]], [combineList[1][0], combineList[1][1]]], 
                        [num1, num2], boxRow, boxCol, this.description);
                    // 如果同时满足在同一个行，同时消除这一行里面的数字
                    if (basicStragety.isSameRow([[combineList[0][0],combineList[0][1]], [combineList[1][0], combineList[1][1]]])) {
                        basicStragety.removeInRow(allCandidates, allReason, [[combineList[0][0],combineList[0][1]], [combineList[1][0], combineList[1][1]]], 
                            [num1, num2], combineList[0][0], this.description);
                    }
                    // 如果同时满足在同一个列，同时消除这一列里面的数字
                    if (basicStragety.isSameCol([[combineList[0][0],combineList[0][1]], [combineList[1][0], combineList[1][1]]])) {
                        basicStragety.removeInCol(allCandidates, allReason, [[combineList[0][0],combineList[0][1]], [combineList[1][0], combineList[1][1]]], 
                            [num1, num2], combineList[0][1], this.description);
                    }

                }
            }
        }
    }
}



export const hiddenPairStrategy = new HiddenPairStrategy()



/*
// 调试信息
let sudoku = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [9, 0, 4, 6, 0, 7, 0, 0, 0],
    [0, 7, 6, 8, 0, 4, 1, 0, 0],
    [3, 0, 9, 7, 0, 1, 0, 8, 0],
    [7, 0, 8, 0, 0, 0, 3, 0, 1],
    [0, 5, 1, 3, 0, 8, 7, 0, 2],
    [0, 0, 7, 5, 0, 2, 6, 1, 0],
    [0, 0, 5, 4, 0, 3, 2, 0, 8],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
];
let sudoku1 = [
    [7, 2, 0, 4, 0, 8, 0, 3, 0],
    [0, 8, 0, 0, 0, 0, 0, 4, 7],
    [4, 0, 1, 0, 7, 6, 8, 0, 2],
    [8, 1, 0, 7, 3, 9, 0, 0, 0],
    [0, 0, 0, 8, 5, 1, 0, 0, 0],
    [0, 0, 0, 2, 6, 4, 0, 8, 0],
    [2, 0, 9, 6, 8, 0, 4, 1, 3],
    [3, 4, 0, 0, 0, 0, 0, 0, 8],
    [1, 6, 8, 9, 4, 3, 2, 7, 5],
];  

console.log(hiddenPairStrategy.apply(sudoku1));
*/

