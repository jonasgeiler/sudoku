import { Strategy } from './strategy.js';
// import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import {basicStragety} from '@sudoku/strategy/basicStrategy.js'
import { lastRemianStrategy } from '@sudoku/strategy/lastRemainStrategy.js';
import { nakePairStrategy  } from './nakePair.js'
import { hiddenPairStrategy } from './hiddenPair.js'
import { threeDMedusaStrategy } from './3DMedusaStrategy.js'


export class StrategyManager {

    constructor() {
        this.strategyList = [];
        this.candidateList = [];
        this.reasonList = [];
    }


    register(strategy) {
        if (strategy && strategy.apply) {
            this.strategyList.push(strategy);
        } else {
            throw new Error('Invalid strategy: Strategy must have an apply method');
        }
    }


    removeStrategy(strategy) {
        this.strategyList = this.strategyList.filter(s => s !== strategy);
    }

     
    inference(sudoku) {
        this.candidateList = [];
        for (const strategy of this.strategyList) {
            const [newCandidates, newReason] = strategy.apply(sudoku);
            this.candidateList.push(newCandidates);
            this.reasonList.push(newReason);
        }
        return this.intersection();
    }



    // 计算所有策略的结果取交集
    intersection() {
        if (this.candidateList.length === 0) {
            return [];
        }
        // 初始化交集为第一个策略的结果
        let intersectionResult = this.candidateList[0];
        let intersectionReason = this.reasonList[0];
        // 逐个计算交集
        for (let i = 1; i < this.candidateList.length; i++) {
            const currentCandidates = this.candidateList[i];
            const currentReanson = this.reasonList[i];
            for (let row = 0; row < intersectionResult.length; row++) {
                for (let col = 0; col < intersectionResult[row].length; col++) {
                    // 候选值结果取交集
                    intersectionResult[row][col] = intersectionResult[row][col].filter(element => currentCandidates[row][col].includes(element));
                    // 理由取并集
                    intersectionReason[row][col] = intersectionReason[row][col].concat(currentReanson[row][col]);
                    intersectionReason[row][col] = intersectionReason[row][col].filter(element => !Array.isArray(element) || element.length !== 0);
                }
            }
        }
        // 返回交集结果
        // 去掉重复元素
        for(let row = 0; row < intersectionReason.length; row ++){
            for (let col = 0; col < intersectionReason[0].length; col ++) {
                intersectionReason[row][col] = [...new Set(intersectionReason[row][col])]
            }
        }
        return [intersectionResult, intersectionReason];
    }

}








// 调试代码
export const strategymanager = new StrategyManager();


// 注册策略
strategymanager.register(basicStragety)
strategymanager.register(lastRemianStrategy)
strategymanager.register(nakePairStrategy);
strategymanager.register(hiddenPairStrategy);
strategymanager.register(threeDMedusaStrategy);


/*
let sudoku = [
    [6, 0, 0, 9, 0, 8, 7, 0, 3],
    [2, 0, 7, 0, 4, 0, 0, 0, 0],
    [0, 5, 0, 0, 0, 0, 6, 0, 0],
    [0, 0, 3, 0, 0, 1, 0, 5, 0],
    [0, 0, 2, 0, 8, 0, 0, 9, 0],
    [1, 4, 0, 0, 3, 0, 0, 0, 2],
    [0, 0, 0, 0, 0, 0, 2, 0, 0],
    [0, 8, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 7],
];


let sudoku = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [5, 0, 9, 8, 0, 0, 0, 1, 0],
    [0, 7, 3, 0, 5, 0, 0, 9, 0],
    [2, 0, 8, 0, 0, 0, 7, 0, 0],
    [0, 0, 0, 6, 8, 0, 0, 5, 0],
    [0, 0, 0, 0, 2, 0, 0, 0, 3],
    [8, 0, 0, 0, 0, 5, 0, 0, 1],
    [7, 0, 0, 0, 0, 3, 0, 6, 0],
    [0, 0, 0, 1, 9, 0, 3, 0, 0],
]

let sudoku = [
    [7, 2, 0, 4, 0, 8, 0, 3, 0],
    [0, 8, 0, 0, 0, 0, 0, 4, 7],
    [4, 0, 1, 0, 7, 6, 8, 0, 2],
    [8, 1, 0, 7, 3, 9, 0, 0, 0],
    [0, 0, 0, 8, 5, 1, 0, 0, 0],
    [0, 0, 0, 2, 6, 4, 0, 8, 0],
    [2, 0, 9, 6, 8, 0, 4, 1, 3],
    [3, 4, 0, 0, 0, 0, 0, 0, 8],
    [1, 6, 8, 9, 4, 3, 2, 7, 5],
]

let sudoku = [
    [6, 0, 0, 0, 1, 3, 8, 9, 0],
    [0, 0, 0, 0, 7, 0, 6, 4, 0],
    [0, 0, 0, 0, 4, 6, 3, 7, 1],
    [0, 0, 0, 0, 0, 0, 2, 0, 4],
    [5, 0, 0, 0, 0, 0, 1, 0, 6],
    [0, 8, 0, 0, 0, 0, 7, 0, 9],
    [0, 0, 5, 3, 6, 2, 9, 1, 8],
    [0, 9, 0, 4, 8, 1, 5, 0, 7],
    [8, 0, 1, 7, 5, 9, 4, 0, 3],
]


let sudoku = [
    [0, 9, 3, 8, 2, 4, 5, 6, 0],
    [0, 8, 5, 6, 0, 0, 0, 0, 2],
    [2, 0, 6, 0, 7, 5, 0, 0, 8],
    [3, 2, 1, 7, 6, 9, 8, 4, 5],
    [0, 0, 0, 2, 5, 8, 3, 0, 0],
    [5, 7, 8, 0, 4, 0, 2, 9, 6],
    [8, 5, 0, 0, 1, 6, 7, 2, 3],
    [0, 0, 7, 0, 8, 2, 6, 5, 0],
    [0, 0, 2, 5, 0, 7, 1, 8, 0],
];

// 应用所有策略
const [allCandidates, allReason] = strategymanager.inference(sudoku);
console.log(allCandidates)
console.log(allReason)
*/





