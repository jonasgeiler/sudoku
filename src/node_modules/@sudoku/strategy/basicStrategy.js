//import { get_all_dirty_from_scope } from 'svelte/internal';
import { Strategy } from './strategy.js';
// import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';




const BOX_SIZE = 3;
const  SUDOKU_SIZE = 9;



export class BasicStrategy extends Strategy {
    constructor() {
        super(0,"Basic Strategy");
    }

    
    apply(sudoku) {
        const allCandidates = Array.from({ length: SUDOKU_SIZE }, () => Array(SUDOKU_SIZE).fill([]));
        const allReason = Array.from({ length: SUDOKU_SIZE }, () => Array(SUDOKU_SIZE).fill([]));
        for (let row = 0; row < SUDOKU_SIZE; row++) {
            for (let column = 0; column < SUDOKU_SIZE; column++) {
                if (sudoku[row][column] === 0) { // 检查单元格是否为空
                    const candidates = this.getCandidateNumber(sudoku, row, column);
                    allCandidates[row][column] = candidates; // 直接赋值，而不是 push
                    allReason[row][column] = allReason[row][column].concat(['Basic SUDOKU rules.']).filter(
                        element => !Array.isArray(element) || element.length !== 0);
                }
            }
        }
        // clue是线索，是文本list的形式
        return [allCandidates, allReason];
    }

    

    getRow(sudoku, row) {
        let nonZeroNumber = [];
        for(let column = 0; column <  SUDOKU_SIZE; column++) {
            if (sudoku[row][column] !== 0) {
                nonZeroNumber.push(sudoku[row][column]);
            }
        }
        return nonZeroNumber;
    }


    getColumn(sudoku, column) {
        let nonZeroNumbers = [];
        for (let row = 0; row < SUDOKU_SIZE; row++) {
            if (sudoku[row][column] !== 0) {
                nonZeroNumbers.push(sudoku[row][column]);
            }
        }
        return nonZeroNumbers;
    }


    getBox(sudoku, row, column) {
        let nonZeroNumbers = [];
        const boxStartRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
        const boxStartColumn = Math.floor(column / BOX_SIZE) * BOX_SIZE;
        for (let i = 0; i < BOX_SIZE; i++) {
            for (let j = 0; j < BOX_SIZE; j++) {
                if (sudoku[boxStartRow + i][boxStartColumn + j] !== 0) {
                    nonZeroNumbers.push(sudoku[boxStartRow + i][boxStartColumn + j]);
                }
            }
        }
        return nonZeroNumbers;
    }


    isValid(sudoku, number, row, column) {
        // 获取行中的非零数字
        const rowNumbers = this.getRow(sudoku, row);
        // 获取列中的非零数字
        const columnNumbers = this.getColumn(sudoku, column);
        // 获取九宫格中的非零数字
        const boxNumbers = this.getBox(sudoku, row, column);
    
        // 检查number是否在行、列或九宫格中的任何一个数组中
        return (rowNumbers.indexOf(number) === -1 &&
                columnNumbers.indexOf(number) === -1 &&
                boxNumbers.indexOf(number) === -1);
    }


    getCandidateNumber(sudoku, row, column) {
        const candidates = [];
        // 遍历所有可能的数字
        for (let number = 1; number <= SUDOKU_SIZE; number++) {
            // 检查该数字是否在指定位置有效
            if (this.isValid(sudoku, number, row, column)) {
                candidates.push(number);
            }
        }
        return candidates;
    }



    // 对于一行内除了特定位置position_list外消除特定的候选值candidate_list
    removeInRow(allCandidates, allReason, position_list, candidate_list, row, strategy_name) {
        for (let col = 0; col < SUDOKU_SIZE; col ++) {
            if(!this.isPositionInList([row, col], position_list)) {
                // 仅仅保留不在candidate_list内的候选数字
                allCandidates[row][col] = allCandidates[row][col].filter(element => !candidate_list.includes(element));
                allReason[row][col] = allReason[row][col].concat([`因为策略${strategy_name}, 候选值${candidate_list}被删除`]).filter(
                    element => !Array.isArray(element) || element.length !== 0);
            }
        }
    }



    // 对于一列内除了特定位置position_list外消除特定的候选值candidate_list
    removeInCol(allCandidates, allReason, position_list, candidate_list, col, strategy_name) {
        for (let row = 0; row < SUDOKU_SIZE; row ++) {
            if(!this.isPositionInList([row, col], position_list)) {
                // 仅仅保留不在candidate_list内的候选数字
                allCandidates[row][col] = allCandidates[row][col].filter(element => !candidate_list.includes(element));
                allReason[row][col] = allReason[row][col].concat([`因为策略${strategy_name}, 候选值${candidate_list}被删除`]).filter(
                    element => !Array.isArray(element) || element.length !== 0);
            }
        }
    }


    // 对于一个九宫格内除了特定位置position_list外消除特定的候选值candidate_list
    removeInBox(allCandidates, allReason, position_list, candidate_list, boxRow, boxCol, strategy_name) {
        for (let boxIndex = 0; boxIndex < BOX_SIZE*BOX_SIZE; boxIndex ++) {
            const row = boxRow*BOX_SIZE + Math.floor(boxIndex / BOX_SIZE);
            const col = boxCol*BOX_SIZE + boxIndex % BOX_SIZE;
            if(!this.isPositionInList([row, col], position_list)) {
                // 仅仅保留不在candidate_list内的候选数字
                allCandidates[row][col] = allCandidates[row][col].filter(element => !candidate_list.includes(element));
                allReason[row][col] = allReason[row][col].concat([`因为策略${strategy_name}, 候选值${candidate_list}被删除`]).filter(
                    element => !Array.isArray(element) || element.length !== 0);
            }
        }
    }


    // 用于解决position位置是否在位置列表position_list中作为其中一个元素
    isPositionInList(position, position_list) {
        return position_list.some(subArray => 
            position.length === subArray.length && 
            position.every((element, index) => element === subArray[index])
        );
    }


    isSameRow(position_list) {
        if(position_list.length < 2) {
            return false;
        }
        const row = position_list[0][0];
        for (let i = 1; i < position_list.legth; i++) {
            if(position_list[i][0] !== row) {
                return false;
            }
        }
        return true;
    }



    isSameCol(position_list) {
        if(position_list.length < 2) {
            return false;
        }
        const col = position_list[0][1];
        for (let i = 1; i < position_list.legth; i++) {
            if(position_list[i][1] !== col) {
                return false;
            }
        }
        return true;
    }


    

    isSameBox(position_list) {
        if(position_list.length < 2) {
            return false;
        }
        let boxRow = [];
        let boxCol = [];
        for (let i = 0; i < position_list.length; i++) {
            boxRow.push(Math.floor(position_list[i][0] / BOX_SIZE) * BOX_SIZE);
            boxCol.push(Math.floor(position_list[i][1] / BOX_SIZE) * BOX_SIZE);
        }
        for (let i = 0; i < position_list.length; i++) {
            if (boxRow[i] !== boxRow[0] || boxCol[i] !== boxCol[0]) {
                return false;
            }
        }
        return true;
    }




    getAmountCandidate(allCandidates) {
        let amount = Array.from({ length: SUDOKU_SIZE }, () => Array(SUDOKU_SIZE).fill(null));
        for (let row = 0; row < SUDOKU_SIZE; row ++) {
            for (let col = 0; col < SUDOKU_SIZE; col++) {
                amount[row][col] = allCandidates[row][col].length;
            }
        }
        return amount;
    }


    isSameAmount(oldAmount, newAmount) {
        for (let row = 0; row < SUDOKU_SIZE; row ++) {
            for (let col = 0; col < SUDOKU_SIZE; col++) {
                if(oldAmount[row][col] !== newAmount[row][col]) {
                    return false;
                }
            }
        }
        return true;
    }


}


export const basicStragety = new BasicStrategy()


 

