import { Strategy } from '@sudoku/strategy/strategy.js';
import {basicStragety} from '@sudoku/strategy/basicStrategy.js'
// import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';


const BOX_SIZE = 3;
const  SUDOKU_SIZE = 9;



export class LastRemianStrategy extends Strategy {
    constructor() {
        super(1, "Last Remian");
    }


    apply(sudoku) {
        const [allCandidates, allReason] = basicStragety.apply(sudoku);
        // 检查行
        for (let row = 0; row < SUDOKU_SIZE; row++) {
            this.findLastRemainInRow(allCandidates, row, allReason);
        }
        // 检查列
        for (let col = 0; col < SUDOKU_SIZE; col++) {
            this.findLastRemainInCol(allCandidates, col, allReason);
        }
        // 检查九宫格
        for (let boxRow = 0; boxRow < SUDOKU_SIZE/BOX_SIZE; boxRow++) {
            for (let boxCol = 0; boxCol < SUDOKU_SIZE/BOX_SIZE; boxCol++) {
                this.findLastRemainInBox(allCandidates, boxRow, boxCol, allReason);
            }
        }
        return [allCandidates, allReason];
         
    }
    

    // 寻找一行内的剩余数字
    findLastRemainInRow(allCandidates, row, allReason) {
        // 对每一个数字进行检查
        for (let candidate = 1; candidate <= SUDOKU_SIZE; candidate++){
            let position = []
            for (let col = 0; col < SUDOKU_SIZE; col ++) {
                if( allCandidates[row][col].length > 0  && allCandidates[row][col].includes(candidate)) {
                    position.push(col);
                } 

            }
            if(position.length === 1) {
                allCandidates[row][position[0]] = [candidate];
                allReason[row][position[0]] = [`Last Remaining in row. The last remaining candidate is ${candidate}`]
            }
        }
    }


    // 寻找一列内的剩余数字
    findLastRemainInCol(allCandidates, col, allReason) {
        // 对每一个数字进行检查
        for (let candidate = 1; candidate <= SUDOKU_SIZE; candidate++){
            let position = []
            for (let row = 0; row < SUDOKU_SIZE; row ++) {
                if( allCandidates[row][col].length > 0  && allCandidates[row][col].includes(candidate)) {
                    position.push(row);
                } 
            }
            if(position.length === 1) {
                allCandidates[position[0]][col] = [candidate];
                allReason[position[0]][col] = [`Last Remaining in column. The last remaining candidate is ${candidate}`]
            }
        }
    }


    // 寻找一个九宫格内的剩余数字
    findLastRemainInBox(allCandidates, boxRow, boxCol, allReason) {
        // 对每一个数字进行检查
        for (let candidate = 1; candidate <= SUDOKU_SIZE; candidate++){
            let position = []
            for (let boxIndex = 0; boxIndex < BOX_SIZE*BOX_SIZE; boxIndex ++) {
                let row = boxRow*BOX_SIZE + Math.floor(boxIndex / BOX_SIZE);
                let col = boxCol*BOX_SIZE + boxIndex % BOX_SIZE;
                if( allCandidates[row][col].length > 0  && allCandidates[row][col].includes(candidate)) {
                    position.push([row, col]);
                } 
            }
            if(position.length === 1) {
                allCandidates[position[0][0]][position[0][1]] = [candidate]
                allReason[position[0][0]][position[0][1]] =  [`Last Remaining in box. The last remaining candidate is ${candidate}`]
            }
        }
    }
}



export const lastRemianStrategy = new  LastRemianStrategy()



