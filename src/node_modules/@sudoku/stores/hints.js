import { writable } from 'svelte/store';
import { settings } from './settings';
import { solveSudoku } from '@sudoku/sudoku';
import { strategymanager } from '@sudoku/strategy/strategymanager';



export const usedHints = writable(0);

// 新增：用于存储提示文字的状态
export const hintText = writable('');
// 新增：用于存储提示文字的列表
export const reasons_list = writable([]);

class Hints {
	#hints;
	#defaultHints;
	#hintLevel;

	constructor() {
		this.#defaultHints = Infinity;
		this.#hints = writable(Infinity);

		settings.subscribe(($settings) => {
			this.#hintLevel = $settings.hintLevel;
			if ($settings.hintsLimited) {
				this.#defaultHints = $settings.hints;
				this.#hints.update(($hints) => {
					if ($hints > $settings.hints) return $settings.hints;
					return $hints;
				});
			} else {
				this.#defaultHints = Infinity;
				this.#hints.set(Infinity);
			}
		});
	}

	subscribe(callback) {
		return this.#hints.subscribe(callback);
	}

	/**
	 * 使用提示功能，返回提示内容。
	 * @param {Array<Array<number>>} currentGrid 当前用户数独网格
	 * @param {Object} pos 提示的坐标 { x, y }
	 * @returns {number|null} 提示的值，若无可用提示则返回 null
	 */
	useHint(currentGrid) {
		let hintValue = [];
		let selections = [];
		let solve = [];
		let reason = [];
		this.#hints.update(($hints) => {
			if ($hints > 0) {
				usedHints.update(($usedHints) => $usedHints + 1);
				selections = this.Candidates_Selection(currentGrid);
				if (this.#hintLevel === 1) { //一级提示：提示所有仅剩一个候选值的单元格
					solve = selections[0];
				} else if (this.#hintLevel === 2) { //二级提示：提示所有剩两个候选值的单元格
					solve = selections[1];
				} else { //三级提示：提示所有候选值 < 9 的单元格
					solve = selections[2];
				}
				return $hints - 1;
			}
			return $hints; // 提示次数为 0，不进行更新
		});
		return solve;
	}

	Candidates_Selection(currentGrid) {
		//三个等级提示的候选值列表
		let level_one_list = [];
		let level_two_list = [];
		let level_three_list = [];

		let candidates_and_reasons = strategymanager.inference(currentGrid);
		let solvedsudoku = candidates_and_reasons[0];
		console.log("Solve:____",candidates_and_reasons[1]);

		reasons_list.set(candidates_and_reasons[1]);
		for (let i = 0; i < solvedsudoku.length; i++) {
			for(let j = 0; j < solvedsudoku[i].length; j++) {

				if (solvedsudoku[i][j].length === 1) {
					level_one_list.push({x:j,y:i,value:solvedsudoku[i][j]});
				} else if (solvedsudoku[i][j].length === 2) {
					level_two_list.push({x:j,y:i,value:solvedsudoku[i][j]});
				}

				if(solvedsudoku[i][j].length > 0) {
					level_three_list.push({x:j,y:i,value:solvedsudoku[i][j]});
				}
			}
		}


		return [level_one_list, level_two_list,level_three_list];

	}

	reset() {
		this.#hints.set(this.#defaultHints);
		usedHints.set(0);
	}
}

export const hints = new Hints();
