import { settings } from '../settings';
import { StrategyTemplate } from '../strategyTemplate';
import { SUDOKU_SIZE } from '../../constants';
import { strategyFactory } from './strategyFactory';


export class MixedStrategy extends StrategyTemplate {

    constructor() {
        super("MixedStrategy");
    }

    execute(grid) {
        const results = [];
        
        let candidates = this.findCandidates(grid);
        const strategyList = this.getStrategyList();
        // 用集合来存有效的策略
        let validStrategyList = new Set();

        // 循环，直到没有可用的策略
        // TODO: 加到常量里面，设置迭代上限
        let maxIterOfStrategies = 10000;
        for(let iter = 0; iter < maxIterOfStrategies; iter++){
            let totalRemoved = 0;
            //迭代执行每一种策略，记录生效的策略
            for (let i = 0; i < strategyList.length; i++) {
                const strategy = strategyList[i];
                removed, candidates = strategy.execute(grid, candidates);
                totalRemoved += removed;
                if (removed > 0) {
                    validStrategyList.add(strategy);
                }
            }
            if (totalRemoved === 0) {
                break;
            }
        }

        // 拼接成要求的格式
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                if (grid[y][x] === 0) {
                    const yxCandidates = candidates[y][x];
                    results.push({ x, y, yxCandidates });
                }
            }
        }
        return results; // 返回找到的所有符合条件的单元格
    }

    // 从settings中获取策略列表，没有这一项则开启全部策略
    getStrategyList(){
        const strategyNameList = settings.get("strategyList");  
        if(!strategyNameList){
            // strategyNameList = ["NakedSingle", "HiddenSingle", "NakedPair", "HiddenPair", "NakedTriple", "HiddenTriple", "X-Wing", "Swordfish", "Jellyfish", "Chain", "Fish", "XYZ", "WXYZ"];
            strategyNameList = ["X-Wing"]
        }
        return strategyNameList.map(strategyName => strategyFactory.create(strategyName));
    }

    findCandidates(grid) {
        // 使用三维数组存候选值，第一维表示行，第二维表示列，第三维表示候选值
        const candidates = Array.from({ length: SUDOKU_SIZE }, () => new Array(SUDOKU_SIZE).fill([]));
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                if (grid[i][j] === 0) {
                    candidates[i][j] = this.getPossibleDigits(grid, i, j);
                }
            }
        }
        return candidates;
    }

    getPossibleDigits(grid, row, col) {
        const digits = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
        for (let i = 0; i < 9; i++) {
            digits.delete(grid[row][i]); // Remove digits in the same row
            digits.delete(grid[i][col]); // Remove digits in the same column
        }
        const boxRowStart = Math.floor(row / 3) * 3;
        const boxColStart = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                digits.delete(grid[boxRowStart + i][boxColStart + j]); // Remove digits in the same box
            }
        }
        return Array.from(digits);
    }
    
}
