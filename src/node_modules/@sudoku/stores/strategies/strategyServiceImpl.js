import { settings } from '@sudoku/stores/settings';
import { StrategyTemplate } from '@sudoku/stores/strategyTemplate';
// import { SUDOKU_SIZE } from '@sudoku/constants';
import { StrategyFactory } from '@sudoku/stores/strategies/strategyFactory';
import { SUDOKU_SIZE,BOX_SIZE } from '@sudoku/constants';
// import { StrategyService } from '@sudoku/stores/strategyService';

// export class strategyServiceImpl extends StrategyService {
// export class StrategyServiceImpl extends StrategyTemplate {
    export class StrategyServiceImpl {

    constructor() {
        // this.name = "MixedStrategy";
        // this.strategyNameList = ["NakedPair","X-Wing", "Y-Wing"];
        // ["X-Wing", "Y-Wing"]
    }

    execute(grid, candidate_grid, strategyNameList) {
        const results = [];
        
        let candidates_ = candidate_grid;
        const strategyList = this.getStrategyList(strategyNameList);
        // 用集合来存有效的策略
        let validStrategyList = new Set();

        // 循环，直到没有可用的策略
        // TODO: 加到常量里面，设置迭代上限
        let maxIterOfStrategies = 10000;
        for (let iter = 0; iter < maxIterOfStrategies; iter++){
            let totalRemoved = 0;
            //迭代执行每一种策略，记录生效的策略
            for (let i = 0; i < strategyList.length; i++) {
                const strategy = strategyList[i];
                let removed = 0;
                removed, candidates_ = strategy.execute(grid, candidates_);
                totalRemoved += removed;
                if (removed > 0) {
                    validStrategyList.add(strategy.getName());
                }
            }
            if (totalRemoved === 0) {
                break;
            }
        }

        // 拼接成要求的格式
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                if (grid[y][x] === 0) {
                    const candidates = candidates_[y][x];
                    results.push({ x, y, candidates });
                }
            }
        }
        return validStrategyList, results; // 返回找到的所有符合条件的单元格
    }

    // 从settings中获取策略列表，没有这一项则开启全部策略
    getStrategyList(strategyNameList){
        // TODO: 等待上层传入settings
        // const strategyNameList = settings.get("strategyList");
        // const strategyNameList = ["X-Wing"];
        // if(!strategyNameList){
        //     // strategyNameList = ["NakedSingle", "HiddenSingle", "NakedPair", "HiddenPair", "NakedTriple", "HiddenTriple", "X-Wing", "Swordfish", "Jellyfish", "Chain", "Fish", "XYZ", "WXYZ"];
        //     strategyNameList = ["X-Wing"]
        // }
        return strategyNameList.map(strategyName => StrategyFactory.create(strategyName));
    }

    findCandidates(grid) {
        // 使用三维数组存候选值，第一维表示行，第二维表示列，第三维表示候选值
        const candidates = Array.from({ length: SUDOKU_SIZE }, () => new Array(SUDOKU_SIZE).fill([]));
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                if (grid[i][j] === 0) {
                    candidates[i][j] = this.getPossibleDigits(grid, i, j);
                }
            }
        }
        return candidates;
    }

    // getPossibleDigits(grid, row, col) {
    //     const digits = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
    //     for (let i = 0; i < 9; i++) {
    //         digits.delete(grid[row][i]); // Remove digits in the same row
    //         digits.delete(grid[i][col]); // Remove digits in the same column
    //     }
    //     const boxRowStart = Math.floor(row / 3) * 3;
    //     const boxColStart = Math.floor(col / 3) * 3;
    //     for (let i = 0; i < 3; i++) {
    //         for (let j = 0; j < 3; j++) {
    //             digits.delete(grid[boxRowStart + i][boxColStart + j]); // Remove digits in the same box
    //         }
    //     }
    //     return Array.from(digits);
    // }
    
    getPossibleDigits(grid, row, col) {
        const y = row, x = col;
        const size = SUDOKU_SIZE;
        const candidates = new Set(Array.from({ length: size }, (_, i) => i + 1));

        // 排除行和列中的已用值
        for (let i = 0; i < size; i++) {
            candidates.delete(grid[y][i]);
            candidates.delete(grid[i][x]);
        }


        // 排除小区域中的已用值
        const boxStartRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;
        const boxStartCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;

        for (let i = 0; i < BOX_SIZE; i++) {
            for (let j = 0; j < BOX_SIZE; j++) {
                candidates.delete(grid[boxStartRow + i][boxStartCol + j]);
            }
        }

        return Array.from(candidates);
    }
}
