export class YWingStrategy {
    constructor() {}

    // 执行Y-Wing策略
    execute(grid, candidates) {
        const newCandidates = JSON.parse(JSON.stringify(candidates)); // 深拷贝避免直接修改原数据
        // 记录总体移除的候选数
        let totalRemoved = 0;
        const maxIterOfStrategy = 1000;
        // 设置迭代上限
        for (let i = 0; i < maxIterOfStrategy; i++) {
            let removed = 0;
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (this.isPivot(newCandidates[row][col])) {
                        const pivot = {row, col};
                        const wings = this.findWings(pivot, newCandidates);

                        for (let i = 0; i < wings.length; i++) {
                            let [pivot, wing1, wing2, sharedNum] = wings[i];
                            removed += this.applyYWingStrategy(pivot, wing1, wing2, sharedNum, newCandidates);
                        }
                    }
                }
            }
            totalRemoved += removed;
            if (removed === 0) {
                break;
            }
        }

        return totalRemoved, newCandidates;
    }

    // 判断是否是枢纽单元
    isPivot(cellCandidates) {
        return cellCandidates.length === 2;
    }

    // 查找可能的翼单元
    findWings(pivot, candidates) {
        let yWings = [];
        let leftWings = [];
        let rightWings = [];
        const [pivotNum1, pivotNum2] = candidates[pivot.row][pivot.col];

        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if ((row !== pivot.row || col !== pivot.col) && this.inSameUnit(pivot, {row, col}) && this.isPivot(candidates[row][col])) {
                    // wings.push({row, col});
                    if (candidates[row][col].includes(pivotNum1) && !candidates[row][col].includes(pivotNum2)) {
                        leftWings.push({row, col});
                    } else if (candidates[row][col].includes(pivotNum2) && !candidates[row][col].includes(pivotNum1)) {
                        rightWings.push({row, col});
                    }
                }
            }
        }

        // 找有相同候选值的左翼和右翼，
        for (let i = 0; i < leftWings.length; i++) {
            for (let j = 0; j < rightWings.length; j++) {
                const [leftWingNum1, leftWingNum2] = candidates[leftWings[i].row][leftWings[i].col];
                if (candidates[rightWings[j].row][rightWings[j].col].includes(leftWingNum1) ){
                    yWings.push([pivot, leftWings[i], rightWings[j], leftWingNum1]);
                } else if (candidates[rightWings[j].row][rightWings[j].col].includes(leftWingNum2)) {
                    yWings.push([pivot, leftWings[i], rightWings[j], leftWingNum2]);
                }
            }
        }

        return yWings;
    }

    // 判断两个位置是否在同一行、列或3x3方块
    inSameUnit(pos1, pos2) {
        return (pos1.row === pos2.row || pos1.col === pos2.col || 
                Math.floor(pos1.row / 3) === Math.floor(pos2.row / 3) && Math.floor(pos1.col / 3) === Math.floor(pos2.col / 3));
    }
    // pos1：Array[2]，pos2：Array[2]
    // isSameUnit(pos1, pos2) {
    //     return (pos1[0] === pos2[0] || pos1[1] === pos2[1] || 
    //             Math.floor(pos1[0] / 3) === Math.floor(pos2[0] / 3) && Math.floor(pos1[1] / 3) === Math.floor(pos2[1] / 3));
    // }
    // 判断是否是潜在的翼单元
    // isWing(cellCandidates, pivotNum1, pivotNum2) {
    //     return cellCandidates.length === 2 && (cellCandidates.includes(pivotNum1) || cellCandidates.includes(pivotNum2));
    // }

    // 判断两个单元是否直接相邻
    areAdjacent(wing, pivot) {
        return Math.abs(wing.row - pivot.row) <= 1 && Math.abs(wing.col - pivot.col) <= 1;
    }

    // 应用Y-Wing策略
    applyYWingStrategy(pivot, wing1, wing2, sharedNum, candidates) {
        // const sharedNum = this.getSharedNumber(candidates[pivot.row][pivot.col], candidates[wing1.row][wing1.col], candidates[wing2.row][wing2.col]);
        // const uniqueNum1 = candidates[wing1.row][wing1.col].find(num => num !== sharedNum && num !== candidates[pivot.row][pivot.col].find(n => n !== sharedNum));
        // const uniqueNum2 = candidates[wing2.row][wing2.col].find(num => num !== sharedNum && num !== candidates[pivot.row][pivot.col].find(n => n !== sharedNum));

        // if (uniqueNum1 === uniqueNum2) {
        let removed = 0;
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (this.inSameUnit({row, col}, wing1) && this.inSameUnit({row, col}, wing2) 
                    && candidates[row][col].includes(sharedNum) 
                    && !this.isSameCell({row, col}, pivot) && !this.isSameCell({row, col}, wing1) && !this.isSameCell({row, col}, wing2)) {
                    candidates[row][col] = candidates[row][col].filter(num => num !== sharedNum);
                    removed++;
                }
            }
        }
        return removed;
        // }
    }

    isSameCell(cell1, cell2) {
        return cell1.row === cell2.row && cell1.col === cell2.col;
    }

    // 获取枢纽和翼单元之间的共享数字
    getSharedNumber(pivotCandidates, wing1Candidates, wing2Candidates) {
        return pivotCandidates.find(num => wing1Candidates.includes(num) && wing2Candidates.includes(num));
    }

    // 判断是否在同一单位（行、列或3x3方块）
    // inSameUnit(row, col, wing1, wing2) {
    //     return (row === wing1.row || row === wing2.row || col === wing1.col || col === wing2.col || 
    //             Math.floor(row / 3) === Math.floor(wing1.row / 3) && Math.floor(col / 3) === Math.floor(wing1.col / 3) ||
    //             Math.floor(row / 3) === Math.floor(wing2.row / 3) && Math.floor(col / 3) === Math.floor(wing2.col / 3));
    // }
}

// 示例使用
// var strategy = new YWingStrategy();
// var updatedCandidates = strategy.execute(grid, candidates);