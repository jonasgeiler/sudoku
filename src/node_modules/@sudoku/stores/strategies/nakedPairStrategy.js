export class NakedPairStrategy {
    constructor() {}

    // 执行Naked Pair策略
    execute(grid, candidates) {
        const newCandidates = JSON.parse(JSON.stringify(candidates)); // 深拷贝避免直接修改原数据

        // 记录总体移除的候选数
        let totalRemoved = 0;
        const maxIterOfStrategy = 1000;
        // 设置迭代上限
        for (let i = 0; i < maxIterOfStrategy; i++) {
            let removed = 0;
            for (let i = 0; i < 9; i++) {
                removed += this.processRow(i, newCandidates);
                removed += this.processColumn(i, newCandidates);
                removed += this.processBlock(i, newCandidates);
            }
            totalRemoved += removed;
            if (removed === 0) {
                break;
            }
        }

        return totalRemoved, newCandidates;
    }

    // 处理每一行
    processRow(rowIndex, candidates) {
        let pairs = this.findPairsInUnit(candidates[rowIndex]);
        return this.applyNakedPairToRow(pairs, rowIndex, candidates);
    }

    applyNakedPairToRow(pairs, rowIndex, candidates) {
        let removed = 0;
        pairs.forEach(pair => {
            const [num1, num2] = pair.numbers;
            const [col1, col2] = pair.indices;
            for (let i = 0; i < 9; i++) {
                if (i!== col1 && i!== col2) {
                    if (candidates[rowIndex][i].includes(num1)) {
                        candidates[rowIndex][i] = candidates[rowIndex][i].filter(num => num !== num1);
                        removed++;
                    }
                    if (candidates[rowIndex][i].includes(num2)) {                        
                        candidates[rowIndex][i] = candidates[rowIndex][i].filter(num => num !== num2);
                        removed++;
                    }
                }
            }
        });

        return removed;
            

    }

    // 处理每一列
    processColumn(colIndex, candidates) {
        let column = [];
        for (let row = 0; row < 9; row++) {
            column.push(candidates[row][colIndex]);
        }
        let pairs = this.findPairsInUnit(column);
        return this.applyNakedPairToColumn(pairs, colIndex, candidates);
    }

    applyNakedPairToColumn(pairs, colIndex, candidates) {
        let removed = 0;
        pairs.forEach(pair => {
            const [num1, num2] = pair.numbers;
            const [row1, row2] = pair.indices;
            for (let i = 0; i < 9; i++) {
                if (i!== row1 && i!== row2) {
                    if (candidates[i][colIndex].includes(num1)) {
                        candidates[i][colIndex] = candidates[i][colIndex].filter(num => num !== num1);
                        removed++;
                    }
                    if (candidates[i][colIndex].includes(num2)) {                        
                        candidates[i][colIndex] = candidates[i][colIndex].filter(num => num !== num2);
                        removed++;
                    }
                }
            }
        });

        return removed;
    }

    // 处理每一个3x3的小方块
    processBlock(blockIndex, candidates) {
        let block = [];
        let startRow = Math.floor(blockIndex / 3) * 3;
        let startCol = (blockIndex % 3) * 3;

        for (let row = startRow; row < startRow + 3; row++) {
            for (let col = startCol; col < startCol + 3; col++) {
                block.push(candidates[row][col]);
            }
        }
        let pairs = this.findPairsInUnit(block);
        return this.applyNakedPairToBlock(pairs, startRow, startCol, candidates);
    }

    applyNakedPairToBlock(pairs, startRow, startCol, candidates) {
        let removed = 0;
        pairs.forEach(pair => {
            const [num1, num2] = pair.numbers;
            const [index1, index2] = pair.indices;
            const row1 = startRow + Math.floor(index1 / 3);
            const row2 = startRow + Math.floor(index2 / 3);
            const col1 = startCol + (index1 % 3);
            const col2 = startCol + (index2 % 3);
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const rowIndex = startRow + i;
                    const colIndex = startCol + j;
                    if (!(rowIndex === row1 && colIndex === col1) && !(rowIndex === row2 && colIndex === col2)) {
                        if (candidates[rowIndex][colIndex].includes(num1)) {
                            candidates[rowIndex][colIndex] = candidates[rowIndex][colIndex].filter(num => num !== num1);
                            removed++;
                        }
                        if (candidates[rowIndex][colIndex].includes(num2)) {                        
                            candidates[rowIndex][colIndex] = candidates[rowIndex][colIndex].filter(num => num !== num2);
                            removed++;
                        }
                    }
                }
            }
        });

        return removed;
    }

    // 查找单元内的Naked Pair
    findPairsInUnit(unit) {
        let pairs = [];
        let pairCounts = {};

        unit.forEach((cell, index) => {
            if (cell.length === 2) { // 只考虑有两个候选数的单元格
                // 排序后作为键进行拼接
                const key = cell.sort().join(',');
                // const key = cell.join(',');
                if (!pairCounts[key]) {
                    pairCounts[key] = [];
                }
                pairCounts[key].push(index);
            }
        });

        Object.keys(pairCounts).forEach(key => {
            if (pairCounts[key].length === 2) { // 确保是Naked Pair
                // pairs.push({indices: pairCounts[key], numbers: key.split(',')});
                // 把类型转回整型
                pairs.push({indices: pairCounts[key], numbers: key.split(',').map(num => parseInt(num))});
            }
        });

        return pairs;
    }

    // 应用Naked Pair策略到单元
    applyNakedPairToUnit(pairs, fixedIndex, variableStart, type, candidates) {
        pairs.forEach(pair => {
            const [num1, num2] = pair.numbers;
            const indices = pair.indices;

            if (type === 'row') {
                this.removeNumbersFromOthers(fixedIndex, indices, num1, num2, candidates);
            } else if (type === 'column') {
                this.removeNumbersFromOthers(indices.map(() => fixedIndex), indices, num1, num2, candidates);
            } else if (type === 'block') {
                const startRow = Math.floor(fixedIndex / 3) * 3;
                const startCol = (fixedIndex % 3) * 3;
                this.removeNumbersFromOthers([startRow, startRow + 1, startRow + 2], [startCol, startCol + 1, startCol + 2], indices, num1, num2, candidates);
            }
        });
    }

    // 从其他单元格中移除指定的候选数
    removeNumbersFromOthers(fixedIndices, variableIndices, num1, num2, candidates) {
        for (let i = 0; i < 9; i++) {
            if (!variableIndices.includes(i)) {
                if (typeof fixedIndices === 'number') {
                    candidates[fixedIndices][i] = candidates[fixedIndices][i].filter(num => num !== parseInt(num1) && num !== parseInt(num2));
                } else {
                    candidates[i][fixedIndices] = candidates[i][fixedIndices].filter(num => num !== parseInt(num1) && num !== parseInt(num2));
                }
            }
        }
    }
}

// 示例使用
// var strategy = new NakedPairStrategy();
// var updatedCandidates = strategy.execute(grid, candidates);