import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSudokuWikiSencode, decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { hints } from './hints';
import {strategyService} from './strategyService'
import { backtrack } from './backtrack'
import { pastCandidatesByStrategy } from './pastCandidatesByStrategy'

function createGrid() {
	const grid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	return {
		subscribe: grid.subscribe,

		generate(difficulty) {
			grid.set(generateSudoku(difficulty));
		},

		decodeSencode(sencode) {
			grid.set(decodeSencode(sencode));
		},
		decodeSudokuWikiSencode(sencode) {
			grid.set(decodeSudokuWikiSencode(sencode));
		},

		get(gridStore, x, y) {
			return gridStore[y][x];
		},

		getSencode(gridStore) {
			return encodeSudoku(gridStore);
		},
		get:() => {
			let currentGrid;
			grid.subscribe($grid => {
				currentGrid = $grid;
			})();
			return currentGrid;
		},
	};
}

export const grid = createGrid();


function createUserGrid() {
	const userGrid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	grid.subscribe($grid => {
		let newGrid = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			newGrid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				newGrid[y][x] = $grid[y][x];
			}
		}

		userGrid.set(newGrid);
	});

	return {
		subscribe: userGrid.subscribe,

		set: (pos, value) => {
			userGrid.update($userGrid => {
				$userGrid[pos.y][pos.x] = value;
				return $userGrid;
			});
		},

		setGrid: (grid) => {	// 设置userGrid
			userGrid.update($userGrid => {
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						$userGrid[y][x] = grid[y][x];
					}
				}
				return $userGrid;
			});
		},

		applyHint: (pos) => {
			hints.useHint();
			userGrid.update($userGrid => {
				const solvedSudoku = solveSudoku($userGrid);
				$userGrid[pos.y][pos.x] = solvedSudoku[pos.y][pos.x];
				return $userGrid;
			});
		},

		sethint: (x,y, value) => {
			userGrid.update($userGrid => {
				$userGrid[y][x] = value;
				return $userGrid;
			});
		},

		get: () => {
			let currentGrid;
			userGrid.subscribe($userGrid => {
				currentGrid = $userGrid;
			})();
			return currentGrid;
		}
	};
}

export const userGrid = createUserGrid();

export const invalidCells = derived(userGrid, $userGrid => {
	const _invalidCells = [];

	const addInvalid = (x, y) => {
		const xy = x + ',' + y;
		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
	};

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {

			const value = $userGrid[y][x];

			if (value) {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					// Check the row
					if (i !== x && $userGrid[y][i] === value) {
						addInvalid(x, y);
					}

					// Check the column
					if (i !== y && $userGrid[i][x] === value) {
						addInvalid(x, i);
					}
				}

				// Check the box
				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const endY = startY + BOX_SIZE;
				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				const endX = startX + BOX_SIZE;
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if (row !== y && col !== x && $userGrid[row][col] === value) {
							addInvalid(col, row);
						}
					}
				}
			}

		}
	}

	return _invalidCells;
}, []);


function createStrategySolution() {
	// strategySolution是一个列表，保存了(x, y, List:candidates[])
	const strategySolution = writable([]);

	userGrid.subscribe(($userGrid) => {
		let newHintSolution = []
		//判断是否此策略下的此棋盘状态是否在字典中了
		if (!pastCandidatesByStrategy.hasUserGrid(userGrid.get(),strategyService.getStrategylist())) {
			//若不在则调用 strategyService
			newHintSolution = strategyService.execute(userGrid.get());
			//将此策略下此棋盘状态的结果存进字典
			pastCandidatesByStrategy.addUserGrid(structuredClone(userGrid.get()),structuredClone(strategyService.getStrategylist()), newHintSolution);
		}
		else{
			newHintSolution = pastCandidatesByStrategy.getStrategy(userGrid.get(),strategyService.getStrategylist());
		}

		console.log(newHintSolution);
		strategySolution.set(newHintSolution); // 更新 strategySolution
		for (const item of newHintSolution) {
			if(item.candidates.length === 0) {
				//TODO:弹出提示框
				alert('no solution!');
				backtrack.toggle();
			}
		}
	});

	return {
		subscribe: strategySolution.subscribe,

		// 用来直接更新列表
		set(newHintSolution) {
			strategySolution.set(newHintSolution);  // 直接用更新列表
		},

		// 清空列表
		clear() {
			strategySolution.set({});
		},

		// 获取字典的列表
		get() {
			let value;
			strategySolution.subscribe($strategySolution => {
				value = $strategySolution;
			})();
			return value;
		}
	};
}

export const strategySolution = createStrategySolution();