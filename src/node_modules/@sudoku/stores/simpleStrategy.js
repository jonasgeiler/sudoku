import { writable } from 'svelte/store';
import {StrategyTemplate} from './strategyTemplate'
import { SUDOKU_SIZE,BOX_SIZE } from '@sudoku/constants';
import { settings } from './settings'

export function createKStore() {
    const kStore = writable(1);

    settings.subscribe(($settings) => {
        kStore.update(($kStore) => {
            // 当 settings.k 变化时，更新 kStore 的值
            if ($settings.k) {
                return $settings.k; // 更新为新的 k 值
            }
            return $kStore; // 保持原值
        });
    });
    return {
        subscribe: kStore.subscribe,
        set: (newValue) => {
            kStore.set(newValue);
        },
        get: () => {
            let currentValue;
            kStore.subscribe(value => {
                currentValue = value;
            })(); // 立即执行订阅，获取当前值
            return currentValue;
        }
    };
}

export const kStore = createKStore();

export class SimpleStrategy extends StrategyTemplate {
    constructor() {
        super("SimpleStrategy");
    }
    execute(grid) {
        //const k = kStore.get();
        const results = [];
        for (let y = 0; y < SUDOKU_SIZE; y++) {
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                if (grid[y][x] === 0) {
                    const candidates = this.getCandidates(grid, x, y);
                    results.push({ x, y, candidates });
                }
            }
        }
        return results; // 返回找到的所有符合条件的单元格
    }

    getCandidates(grid, x, y) {
        const size = SUDOKU_SIZE;
        const candidates = new Set(Array.from({ length: size }, (_, i) => i + 1));

        // 排除行和列中的已用值
        for (let i = 0; i < size; i++) {
            candidates.delete(grid[y][i]);
            candidates.delete(grid[i][x]);
        }


        // 排除小区域中的已用值
        const boxStartRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;
        const boxStartCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;

        for (let i = 0; i < BOX_SIZE; i++) {
            for (let j = 0; j < BOX_SIZE; j++) {
                candidates.delete(grid[boxStartRow + i][boxStartCol + j]);
            }
        }

        return Array.from(candidates);
    }
    
}
