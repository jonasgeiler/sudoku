import { StrategyServiceImpl } from './strategies/strategyServiceImpl';
import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';
import { PastSolutionByStrategy } from '@sudoku/stores/pastSolutionByStrategy.js';
import { CandidateGrid } from '@sudoku/stores/candidateGrid.js';

class StrategyService {
    constructor() {
        this.strategyServiceImpl = new StrategyServiceImpl();
        // this.strategyNameList = ["NakedPair","X-Wing", "Y-Wing"];
        this.strategyNameList = ["NakedPair","X-Wing", "Y-Wing"];
        this.pastSolutionByStrategy = new PastSolutionByStrategy();
        this.initCandidateGrid = new CandidateGrid();
    }

    setInitCandidateGrid(candidate_grid) {
        this.initCandidateGrid = candidate_grid;
        console.log(this.initCandidateGrid);
    }

    /**
     * 执行所有策略
     * @param {Array<Array<number>>} grid - 当前的数独棋盘
     * @returns {Array} - 每个策略的执行结果
     */
    execute(grid) {
        if (this.pastSolutionByStrategy.hasUserGrid(grid, this.strategyNameList)) {
            const solution = this.pastSolutionByStrategy.getSolution(grid, this.strategyNameList);
            return solution;
        }

        let candidate_grid = this.preprocessCandidateGrid(grid, this.initCandidateGrid);
        const solution = this.strategyServiceImpl.execute(grid, candidate_grid, this.strategyNameList);
        this.pastSolutionByStrategy.addUserGrid(grid, structuredClone(this.strategyNameList), solution);

        console.log(candidate_grid);

        return solution;
    }

    //仅测试，后续有待zhu神出手
    getStrategylist() {
        return [this.strategyServiceImpl.name];
    }

    preprocessCandidateGrid(grid, initCandidateGrid) {
        // 使用三维数组存候选值，第一维表示行，第二维表示列，第三维表示候选值
        const candidateGrid = initCandidateGrid.clone();
        console.log(candidateGrid);
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                if (grid[i][j] !== 0) 
                    candidateGrid.clear(j, i); // y = i, x = j
                else {
                    let sameNumberList = this.getSameNumberAtRowColBox(grid, i, j);
                    candidateGrid.deleteMultiNumbers(j, i, sameNumberList);
                }
            }
        }
        console.log(candidateGrid);
        return candidateGrid.array;
    }

    getSameNumberAtRowColBox(grid, row, col) {
        const y = row, x = col;
        const size = SUDOKU_SIZE;
        const sameNumberList = []

        // 排除行和列中的已用值
        for (let i = 0; i < size; i++) {
            sameNumberList.push(grid[y][i]);
            sameNumberList.push(grid[i][x]);
        }

        // 排除小区域中的已用值
        const boxStartRow = Math.floor(y / BOX_SIZE) * BOX_SIZE;
        const boxStartCol = Math.floor(x / BOX_SIZE) * BOX_SIZE;

        for (let i = 0; i < BOX_SIZE; i++) {
            for (let j = 0; j < BOX_SIZE; j++) {
                sameNumberList.push(grid[boxStartRow + i][boxStartCol + j]);
            }
        }
        
        console.log(col + "," + row);
        console.log(sameNumberList);
        return sameNumberList;
    }
}

export const strategyService = new StrategyService();