import { writable } from 'svelte/store';
import { hintStore } from '@sudoku/stores/hintStore';
import { grid, userGrid } from '@sudoku/stores/grid';

// 用于存储所有提示内容
let allHints = [];

// 订阅 hintStore，获取所有提示数据
hintStore.subscribe(hints => {
  allHints = hints; // 保存整个 hintStore 列表
});

/****************************************
 * 数独树节点类
 ****************************************/
class SudokuNode {
  constructor(id, grid) {
    this.id = id;
    this.grid = grid;

    // 父、子节点
    this.parent = null;
    this.children = null;

    // 已经被证实无效的猜测 (比如本节点走到死胡同)
    this.invalidhints = new Set();
  }

  /**
   * 往本节点添加一个子节点
   * @param {SudokuNode} childNode
   */
  addChild(childNode) {
    childNode.parent = this;
    this.children = childNode;
  }
}

/****************************************
 * 数独树管理器
 ****************************************/
class SudokuTreeManager {
  /**
   * @param {object} initialGameState - 初始的数独盘面数据
   */
  constructor() {
    // 用于生成节点 id
    this.nodeCounter = 0;
    // 如果不想用全局 nodeMap，也可以单独在这里维护
    this.localNodeMap = new Map();
    this.rootNode = null;
    // currentNode 表示当前所处的节点（“游标”）
    this.currentNode = null;

    // 栈，用于存储符合条件的节点 id
    this.nodeStack = [];

    // 建立一个内部的 store，专门用来让 Svelte 追踪变化
    this._state = writable({
      currentNode: this.currentNode,
      nodeStack: this.nodeStack,
      canGoToParent: false,
      canGoToSon: false,
      isStackEmpty: true
    });
  }

  get store() {
    // 组件中会通过 manager.store 拿到这个可写 store
    return this._state;
  }

  // 内部方法：更新 store 状态
  _updateStore() {
    this._state.set({
      currentNode: this.currentNode,
      nodeStack: this.nodeStack,
      canGoToParent: this.canGoToParent(),
      canGoToSon: this.canGoToSon(),
      isStackEmpty: this.isStackEmpty()
    });
  }

  /**
   * 内部方法：生成一个唯一节点 id
   * @returns {string}
   */
  _genNodeId() {
    const id = `node-${this.nodeCounter}`;
    this.nodeCounter++;
    return id;
  }

  generate(grid) {
    // 创建根节点
    const rootId = this._genNodeId();
    this.rootNode = new SudokuNode(rootId, grid);
    // 也放到本地 Map 里
    this.localNodeMap.set(rootId, this.rootNode);
    // currentNode 表示当前所处的节点（“游标”）
    this.currentNode = this.rootNode;
    console.warn("Create root node");

    this._updateStore(); // 每次修改 currentNode 后，都更新一下
  }

  /**
   * 创建一个新的子节点，并挂到指定的 parentNode 下
   * @param {object} gameState - 新节点对应的游戏盘面
   * @param {object} parentNode - 父节点
   * @param {object} [options] - 包含 guessedCell, guessedValue 等
   * @returns {SudokuNode} - 新创建的子节点
   */
  createChildNode(newgrid, parentNode = this.currentNode) {
    console.log("The parent grid before:", parentNode.grid);
    const newId = this._genNodeId();
    const child = new SudokuNode(newId, newgrid);
    parentNode.addChild(child);

    // 本地也登记一下
    this.localNodeMap.set(newId, child);
    this.currentNode = child;
    this._updateStore(); // 更新 store
    console.log("Create child grid", grid);
    console.log("The parent grid", parentNode.grid);
    return child;
  }

  /**
   * 把 currentNode 切换到指定的节点 id
   * 这就是所谓的“快速跳”
   * @param {string} nodeId
   */
  jumpToNode(nodeId) {
    const targetNode = this.localNodeMap.get(nodeId);
    if (!targetNode) {
      console.error(`Node with id=${nodeId} not found in localNodeMap!`);
      return;
    }
    this.currentNode = targetNode;
    userGrid.setGrid(this.currentNode.grid);
    console.log(`Jumped to node: ${nodeId}`);

    this._updateStore(); // 更新 store
  }

  /**
   * 回到父节点 (若有)
   */
  canGoToParent() {
    return this.currentNode && this.currentNode.parent !== null;
  }
  goToParent() {
    if (this.currentNode && this.currentNode.parent) {
      this.currentNode = this.currentNode.parent;
      console.log("this.currentNode.grid:", this.currentNode.grid);
      userGrid.setGrid(this.currentNode.grid);

      console.log(`Went back to parent: ${this.currentNode.id}`);
      this._updateStore(); // 更新 store
    } else {
      console.warn("Current node has no parent!");
    }
  }

  /**
   * 回到子节点 (若有)
   */
  canGoToSon() {
    return this.currentNode && this.currentNode.children !== null;
  }
  goToSon() {
    if (this.currentNode && this.currentNode.children) {
      this.currentNode = this.currentNode.children;
      console.log("this.currentNode.grid:", this.currentNode.grid);
      userGrid.setGrid(this.currentNode.grid);
      console.log(`Went back to children: ${this.currentNode.id}`);
      this._updateStore(); // 更新 store
    } else {
      console.warn("Current node has no children!");
    }
  }

  /**
   * 演示：标记当前节点的某个猜测值为无效
   * @param {number} value
   */
  markInvalidGuess(value) {
    this.currentNode.invalidGuesses.add(value);
    console.log(`Marked guess "${value}" as invalid in node ${this.currentNode.id}`);
  }

  isStackEmpty() {
    const empty = this.nodeStack.length === 0;
    return empty;
  }

  pushToStack() {
    this.nodeStack.push(this.currentNode.id);
    console.log(`Pushed node id "${this.currentNode.id}" to stack.`);
  }

  /**
   * 从栈中弹出最顶端的 id 并跳转到对应的节点
   */
  popFromStack() {
    if (this.nodeStack.length === 0) {
      console.warn("Stack is empty. Cannot pop.");
      return;
    }
    const nodeId = this.nodeStack.pop();
    console.log(`Popped node id "${nodeId}" from stack.`);
    this.jumpToNode(nodeId);
  }

}

export const sudokutreemanager = new SudokuTreeManager();
