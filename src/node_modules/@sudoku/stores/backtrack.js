import { writable, get } from 'svelte/store';

function createBacktrackStore() {
    const { subscribe, set, update } = writable({
        branchPoints: {},
        currentBranch: null
    });

    return {
        subscribe,
        
        // 记录分支点
        recordBranch: (position, candidates, selectedValue, explanation) => update(state => {
            const key = `${position.x},${position.y}`;
            const branchPoints = {...state.branchPoints};
            
            if (!branchPoints[key]) {
                // 新建分支点
                branchPoints[key] = {
                    position: {...position},
                    candidates: candidates.map(Number), // 确保所有候选值都是数字类型
                    attempts: selectedValue ? [Number(selectedValue)] : [], // 如果有选中值则记录
                    explanation,
                    timestamp: Date.now() // 添加时间戳
                };
            } else {
                // 更新现有分支点
                if (selectedValue) {
                    branchPoints[key].attempts = [
                        ...new Set([...branchPoints[key].attempts, Number(selectedValue)])
                    ];
                }
            }
            
            return {
                branchPoints,
                currentBranch: key
            };
        }),
        
        // 获取未尝试的候选值
        getRemainingCandidates: (position) => {
            const state = get(backtrack);
            const key = `${position.x},${position.y}`;
            const branch = state.branchPoints[key];
            
            if (!branch) return null;
            
            return branch.candidates.filter(c => !branch.attempts.includes(c));
        },
        
        // 清空指定分支点之后的所有分支
        clearAfter: (position) => update(state => {
            const key = `${position.x},${position.y}`;
            const timestamp = state.branchPoints[key].timestamp;
            
            // 筛选出需要保留的分支点
            const filteredBranchPoints = {};
            Object.entries(state.branchPoints).forEach(([k, v]) => {
                if (v.timestamp <= timestamp) {
                    filteredBranchPoints[k] = v;
                }
            });
            
            return {
                branchPoints: filteredBranchPoints,
                currentBranch: key
            };
        })
    };
}

export const backtrack = createBacktrackStore();