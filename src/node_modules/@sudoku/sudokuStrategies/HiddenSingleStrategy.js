import Strategy from './Strategy';

export default class HiddenSingleStrategy extends Strategy{

    /**
     * 应用 Hidden Single 策略
     * @param {number[][]} grid - 当前棋盘
     * @param {Array<Array<number[]>>} candidates - 当前候选值
     * @returns {Array<Array<number[]>>} - 更新后的候选值
     */
    apply(grid, candidates) {
        const SUDOKU_SIZE = 9;

        // 深拷贝当前候选值，避免直接修改原始候选值
        const newCandidates = candidates.map(row => row.map(cell => [...cell]));

        // 遍历行
        for (let row = 0; row < SUDOKU_SIZE; row++) {
            const rowCandidates = newCandidates[row];
            this.updateHiddenSingles(rowCandidates, newCandidates, row, "row");
        }

        // 遍历列
        for (let col = 0; col < SUDOKU_SIZE; col++) {
            const columnCandidates = newCandidates.map(row => row[col]);
            this.updateHiddenSingles(columnCandidates, newCandidates, col, "column");
        }

        // 遍历 3x3 宫格
        for (let boxRow = 0; boxRow < 3; boxRow++) {
            for (let boxCol = 0; boxCol < 3; boxCol++) {
                const boxCandidates = [];
                const positions = [];

                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const row = boxRow * 3 + i;
                        const col = boxCol * 3 + j;
                        boxCandidates.push(newCandidates[row][col]);
                        positions.push([row, col]);
                    }
                }

                this.updateHiddenSingles(boxCandidates, newCandidates, positions, "box");
            }
        }
//        console.log(newCandidates);
        return newCandidates;
    }

    /**
     * 更新隐藏单一解
     * @param {Array<number[]>} scopeCandidates - 当前范围（行/列/宫格）内的候选值
     * @param {Array<Array<number[]>>} candidates - 全局候选值
     * @param {number | Array<number[]>} scopeIdentifier - 当前范围的标识（行号/列号/宫格位置）
     * @param {string} scopeType - 当前范围类型（"row"|"column"|"box"）
     */
    updateHiddenSingles(scopeCandidates, candidates, scopeIdentifier, scopeType) {
        const SUDOKU_SIZE = 9;

        // 统计每个数字在当前范围内的出现次数
        const countMap = new Map();
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            const cellCandidates = scopeCandidates[i];
            cellCandidates.forEach(candidate => {
                countMap.set(candidate, (countMap.get(candidate) || 0) + 1);
            });
        }

        // 找到每个数字的唯一位置
        for (let [candidate, count] of countMap.entries()) {
            if (count === 1) {
                // 找到唯一出现的候选值
                for (let i = 0; i < SUDOKU_SIZE; i++) {
                    if (scopeCandidates[i].includes(candidate)) {
                        // 根据范围类型更新全局候选值
                        if (scopeType === "row") {
                            const row = scopeIdentifier;
                            const col = i;
                            candidates[row][col] = [candidate]; // 更新候选值
                        } else if (scopeType === "column") {
                            const row = i;
                            const col = scopeIdentifier;
                            candidates[row][col] = [candidate]; // 更新候选值
                        } else if (scopeType === "box") {
                            const [row, col] = scopeIdentifier[i];
                            candidates[row][col] = [candidate]; // 更新候选值
                        }
                        break;
                    }
                }
            }
        }
    }
}
