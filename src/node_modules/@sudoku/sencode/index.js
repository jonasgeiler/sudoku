import { GRID_COORDS, SUDOKU_SIZE, GRID_LENGTH, SENCODE_REGEX, SENCODE_SEPARATOR as SEPARATOR, SENCODE_SEPARATOR_REVERSE as SEPARATOR_REVERSE } from '@sudoku/constants';
import Base62 from './base62';


/**
 * @param {number[]} flatGrid
 * @returns {boolean}
 */
function shouldReverse(flatGrid) {
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		if (flatGrid[(GRID_LENGTH - 1) - cell] !== 0) {
			return false;
		} else if (flatGrid[cell] !== 0) {
			return true;
		}
	}

	return false;
}


/**
 * @param {number[][]} sudoku
 * @returns {string}
 */
export function encodeSudoku(sudoku) {
	/** @type number[] */
	const flatGrid = sudoku.flat();

	const reversed = shouldReverse(flatGrid);
	if (reversed) {
		// Reverse sudoku array
		flatGrid.reverse();
	}

	let structure = '';
	let numbers = '';

	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		structure += (flatGrid[cell] === 0 ? '0' : '1');

		if (flatGrid[cell] > 0) {
			numbers += flatGrid[cell] - 1; // Subtract 1 so the number gets smaller
		}
	}

	return Base62.encode(BigInt('0b' + structure)) +
	       (reversed ? SEPARATOR_REVERSE : SEPARATOR) +
	       Base62.encode(BigInt(numbers));
}


/**
 * @param {string} sencode
 * @returns {number[][]}
 */
export function decodeSencode(sencode) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	let sudokuSencodeGridStr = sencode.replace("https://www.sudokuwiki.org/sudoku.htm?bd=", "").replace(" ", "")

	let numberCount = 0;
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		grid[Math.floor(cell / SUDOKU_SIZE)][cell % SUDOKU_SIZE] = Number(sudokuSencodeGridStr.charAt(cell));
	}

	return grid;
}


/**
 * @param {string} sencode
 * @returns {number[][]}
 */
export function decodeSudokuWikiSencode(sencode) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	let sudokuSencodeGridStr = sencode.replace("https://www.sudokuwiki.org/sudoku.htm?bd=", "").replace(" ", "")

	let numberCount = 0;
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		grid[Math.floor(cell / SUDOKU_SIZE)][cell % SUDOKU_SIZE] = Number(sudokuSencodeGridStr.charAt(cell));
	}

	return grid;
}


/**
 * @param {string} sencode
 * @returns {number[][]}
 */
export function decodeSudokuTestSencode(sencode) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	let numberCount = 0;
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		grid[Math.floor(cell / SUDOKU_SIZE)][cell % SUDOKU_SIZE] = Number(sudokuSencodeGridStr.charAt(cell));
	}

	return grid;
}


/**
 * @param {string} sencode
 * @returns {boolean}
 */
// 300967001040302080020000070070000090000873000500010003004705100905000207800621004
// 3[123]09670010403020800200000700700000900008730005000100030047051009050002078006210[567]4
function matchesSencodePattern(str) {
	const regex = /^(\d|(\[\d{0,9}\])){81}$/;
	const match = str.match(regex);
	if (match) return true;
	return false;
}

/**
 * @param {string} sencode
 * @returns {int}
 */
// https://www.sudokuwiki.org/sudoku.htm?bd=300967001040302080020000070070000090000873000500010003004705100905000207800621004
function sudokuWikiSencode(sencode) {
	let sudokuSencodeGridStr = sencode.replace("https://www.sudokuwiki.org/sudoku.htm?bd=", "").replace(" ", "")
	if(matchesSencodePattern(sudokuSencodeGridStr))
		return true;
	return false;
}


/**
 * @param {string} sencode
 * @returns {boolean}
 */
// export function validateSencode(sencode) {
// 	return sencode && sencode.trim().length !== 0 && SENCODE_REGEX.test(sencode);
// }
export function validateSencode(sencode) {
	return sencode && sencode.trim().length !== 0 && sudokuWikiSencode(sencode);	
}