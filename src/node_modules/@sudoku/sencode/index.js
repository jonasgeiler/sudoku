import { GRID_COORDS, SUDOKU_SIZE, GRID_LENGTH, SENCODE_REGEX, SENCODE_SEPARATOR as SEPARATOR, SENCODE_SEPARATOR_REVERSE as SEPARATOR_REVERSE } from '@sudoku/constants';
import Base62 from './base62';
import { CandidateGrid, readFromCandidateList } from '@sudoku/stores/candidateGrid.js';


/**
 * @param {number[]} flatGrid
 * @returns {boolean}
 */
function shouldReverse(flatGrid) {
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		if (flatGrid[(GRID_LENGTH - 1) - cell] !== 0) {
			return false;
		} else if (flatGrid[cell] !== 0) {
			return true;
		}
	}

	return false;
}


/**
 * @param {number[][]} sudoku
 * @returns {string}
 */
export function encodeSudoku(grid, candidateList) {
	let candidate_grid = readFromCandidateList(candidateList);
	let sudokuSencodeGridStr = "";
	for(let y = 0; y < SUDOKU_SIZE; y++)
		for(let x = 0; x < SUDOKU_SIZE; x++) {
			if(grid[y][x] !== 0) {
				sudokuSencodeGridStr += grid[y][x];
				continue;
			}
			sudokuSencodeGridStr += "[";
			let candidates = candidate_grid.get(x, y);
			for(let i = 0; i < candidates.length; i++)
				sudokuSencodeGridStr += candidates[i];
			sudokuSencodeGridStr += "]";
		
		}
	return sudokuSencodeGridStr;
}

/**
 * @param {string} sencode
 * @returns { number[][], [x, y, candidates[]] }
 */
export function decodeSencode(sencode) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	let sudokuSencodeGridStr = sencode.replace("https://www.sudokuwiki.org/sudoku.htm?bd=", "").replace(" ", "")

	let numberCount = 0;
	let candidateList = [];
	let strIndex = 0;
	for (let cell = 0, strIndex = 0; strIndex < sudokuSencodeGridStr.length; cell++, strIndex++) {
		let ch = sudokuSencodeGridStr.charAt(strIndex);
		let y = Math.floor(cell / SUDOKU_SIZE);
		let x = cell % SUDOKU_SIZE;
		if(ch != '[') {
			grid[y][x] = Number(sudokuSencodeGridStr.charAt(strIndex));
			if(grid[y][x] === 0) {
				candidateList.push({ x, y, candidates:[1,2,3,4,5,6,7,8,9] });
			}
		}
		else {
			grid[y][x] = 0;
			strIndex++;
			let candidates = [];
			for (; strIndex < sudokuSencodeGridStr.length && sudokuSencodeGridStr.charAt(strIndex) != ']'; strIndex++)
				candidates.push(Number(sudokuSencodeGridStr.charAt(strIndex)));
			candidateList.push({ x, y, candidates });
		}
	}

	return {grid: grid, candidateList: candidateList};
}


/**
 * @param {string} sencode
 * @returns {number[][]}
 */
export function decodeSencodeForGrid(sencode) {
	return decodeSencode(sencode)["grid"];
}


/**
 * @param {string} sencode
 * @returns {[x, y, candidates[]]}
 */
export function decodeSencodeForCandidateList(sencode) {
	return decodeSencode(sencode)["candidateList"];
}
/**
 * @param {string} sencode
 * @returns {[x, y, candidates[]]}
 */
export function decodeSencodeForCandidateGrid(sencode) {
	let sudokuSencodeGridStr = sencode.replace("https://www.sudokuwiki.org/sudoku.htm?bd=", "").replace(" ", "")

	let candidate_grid = new CandidateGrid();
	for (let cell = 0, strIndex = 0; strIndex < sudokuSencodeGridStr.length; cell++, strIndex++) {
		let ch = sudokuSencodeGridStr.charAt(strIndex);
		let y = Math.floor(cell / SUDOKU_SIZE);
		let x = cell % SUDOKU_SIZE;
		if(ch != '[') {
			
		}
		else {
			strIndex++;
			console.log(candidate_grid);
			candidate_grid.clear(x, y);
			console.log(candidate_grid);
			for (; strIndex < sudokuSencodeGridStr.length && sudokuSencodeGridStr.charAt(strIndex) != ']'; strIndex++)
				candidate_grid.add(x, y, Number(sudokuSencodeGridStr.charAt(strIndex))),
				console.log(x + ", " + y + ": " + Number(sudokuSencodeGridStr.charAt(strIndex))),
				console.log(candidate_grid);
		}
	}

	return candidate_grid;
}



/**
 * @param {string} sencode
 * @returns {boolean}
 */
// 300967001040302080020000070070000090000873000500010003004705100905000207800621004
// 3[57]09670010403020800200000700700000900008730005000100030047051009050002078006210[567]4
function matchesSencodePattern(str) {
	const regex = /^(\d|(\[\d{0,9}\])){81}$/;
	const match = str.match(regex);
	if (match) return true;
	return false;
}

/**
 * @param {string} sencode
 * @returns {int}
 */
// https://www.sudokuwiki.org/sudoku.htm?bd=300967001040302080020000070070000090000873000500010003004705100905000207800621004
function sudokuWikiSencode(sencode) {
	let sudokuSencodeGridStr = sencode.replace("https://www.sudokuwiki.org/sudoku.htm?bd=", "").replace(" ", "")
	if(matchesSencodePattern(sudokuSencodeGridStr))
		return true;
	return false;
}


/**
 * @param {string} sencode
 * @returns {boolean}
 */
// export function validateSencode(sencode) {
// 	return sencode && sencode.trim().length !== 0 && SENCODE_REGEX.test(sencode);
// }
export function validateSencode(sencode) {
	return sencode && sencode.trim().length !== 0 && sudokuWikiSencode(sencode);	
}