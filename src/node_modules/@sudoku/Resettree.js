import { userGrid } from '@sudoku/stores/grid';
import { candidates } from '@sudoku/stores/candidates';
import { SUDOKU_SIZE } from '@sudoku/constants';

// 回溯错误值
export let errorValue = {"number": undefined, "index": {}}; //number: int; index: {"x": 0, "y": 0}

// 复制当前userGrid（$userGrid会自动更新，不能用$userGrid传值）
export function copyUserGrid(grid) {
    let newGrid = [];
    for (let y = 0; y < SUDOKU_SIZE; y++) {
        newGrid[y] = [];
        for (let x = 0; x < SUDOKU_SIZE; x++) {
            newGrid[y][x] = grid[y][x];
        }
    }
    return newGrid;
}
// 复制当前candidates（$candidates会自动更新，不能用$candidates传值）
export function copyCandidates(candidates) {
    let newCandidates = {};
    for (let [key, value] of Object.entries(candidates)) {
        newCandidates[key] = [];
        for (let i = 0; i < value.length; i++) {
            newCandidates[key].push(value[i])
        }
    }
    return newCandidates;
}

// "x, y" to {x, y}
function convertCandidateStringToObject(str) {
    console.log("str: ", str);
    const parts = str.split(',');
    if (parts.length !== 2) {
        return {};
    }
    const x = parseInt(parts[0], 10);
    const y = parseInt(parts[1], 10);
    return {x, y};
}

// 重置usergrid
export function resetUserGrid(grid) {
    for (let y = 0; y < SUDOKU_SIZE; y++) {
        for (let x = 0; x < SUDOKU_SIZE; x++) {
            userGrid.set({y, x}, grid[y][x]);
        }
    }
}

// 重置Candidates
export function resetCandidates(candidates_bk){
    // 清空所有候选值
    for (let y = 0; y < SUDOKU_SIZE; y++) {
        for (let x = 0; x < SUDOKU_SIZE; x++) {
            candidates.clear({y, x});
        }
    }
    // 重置候选值
    for (let [key, value] of Object.entries(candidates_bk)) {
        let pos = convertCandidateStringToObject(key);
        candidates.clear(pos);
        for (let i of value)
            candidates.add(pos, i);
    }
}

// grid序列化和反序列化
export function gridSerialization(grid) {
    const serializedArray = JSON.stringify(grid);
    return serializedArray;
}
function gridDeserialization(serializedArray) {
    const deserializedArray = JSON.parse(serializedArray);
    return deserializedArray;
}

// DAG树
function DagNode() {
    this.parent = null;
    this.children = [];
    this.recent_visit_child = null;
    
    this.grid_bk;       //grid备份
    this.number;        //输入的数字
    this.reset_point = false;//回溯点标志
    this.failure = false;   //失败分支标志
//    this.candidates_bk; // hang up
}
function DagTree(){
    this.root = null;
    this.current = this.root;

    //保存新局grid
    this.initiate = function(grid_bk) {
        console.log("initiate");

        // 增加子节点
        let new_node = new DagNode();
        new_node.parent = null;
        new_node.grid_bk = grid_bk;
        this.current = this.root = new_node;
    };
    this.push = function(number, grid_bk, reset_point = false){
        console.log("push");
        for (let i = 0; i < this.current.children.length; i++)
        {
            if (this.current.children[i].grid_bk === grid_bk)
            {
                this.current = this.current.children[i];
                return;
            }
        }

        // 增加子节点
        let new_node = new DagNode();
        new_node.parent = this.current;
        new_node.grid_bk = grid_bk;
        new_node.number = number
        new_node.reset_point = reset_point;

        this.current.children.push(new_node);
        this.current = this.current.children[this.current.children.length-1];
    };
    //撤销
    this.undo = function() {
        console.log("undo");
        if (this.current.parent === null)
            return false;

        this.current.parent.recent_visit_child = this.current;
        this.current = this.current.parent;
        resetUserGrid(gridDeserialization(this.current.grid_bk));
        return true;
    };
    //恢复
    this.redo = function() {
        console.log("redo");
        if (this.current.children.length === 0 || this.current.recent_visit_child === null)
            return false;

        this.current = this.current.recent_visit_child;
        resetUserGrid(gridDeserialization(this.current.grid_bk));
        return true;
    };
    // 回溯
    this.reset = function() {
        console.log("reset");
        while (this.current !== this.root && this.current.reset_point === false)
        {
            this.current.parent.failure = this.current.failure;
            this.current = this.current.parent;
        }
        resetUserGrid(gridDeserialization(this.current.grid_bk));
    }
    //标志分支失败
    this.setFailure = function(){
        this.current.failure = true;
    }
    this.hasResetPoint = function() {
        // 检查是否有ResetCommand

        let traverse_node = this.current;
        while(traverse_node !== this.root && traverse_node.reset_point === false)
        {
            traverse_node = traverse_node.parent;
        }

        return traverse_node.reset_opint;
    };
}
export let ResetTree = new DagTree();
